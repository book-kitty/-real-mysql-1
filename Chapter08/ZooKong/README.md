# 인덱스

- 데이터베이스 쿼리 성능에 큰 영향
- MyISAM 스토리지 엔진에서만 지원하는 전문 검색, 위치 기반 검색 기능도 InnoDB 스토리지 엔진에서 사용 가능

## 1. 디스크 읽기 방식

### 1.1. 하드 디스크 드라이브(HDD)와 솔리드 스테이트 드라이브(SSD)

- SSD는 기존 데이터 저장용 플래터(원판)을 제거, 플레시 메모리 장착
  - 디스크 원판을 기계적으로 회전시킬 필요가 없음
  - 플래시 메모리는 전원 공급이 없어도 데이터가 삭제되지 않음
  - 컴퓨터 메모리(D-Ram) 보다 느리지만 기계식 하드 디스크 드라이브보다는 훨씬 빠름
- 디스크 헤더를 움직이지 않고 한번에 많은 데이터를 순차 I/O할 경우 SSD가 조금 빠르거나 비슷
- 랜덤 I/O에서는 SSD가 훨씬 빠름

### 1.2. 랜덤 I/O와 순차 I/O

- 랜덤 I/O는 데이터 접근에 대해 물리적 지역성 없이 랜덤하여 I/O를 수행
  - 디스크 기록을 위해 디스크 헤더를 이곳 저곳 움직이는 상황이 이에 속함
- 순차 I/O는 데이터 접근에 대해 물리적 지역성을 통해 I/O를 수행
  - 디스크 기록을 위해 하나의 디스크 헤더로만 이동하여 작업하는 것이 이에 속함
- 데이터베에스에서 I/O는 빈번하게 발생, 그룹 커밋, 바이너리 로그 버퍼 등의 기능이 내장
- SSD도 랜덤, 순차 I/O의 성능상 차이가 존재
  - SSD 사양에서 구분해서 명시

> RAID 컨트롤러를 통해 순차 I/O를 효율적으로 하는 내용이 참고로 언급, 해당 단원을 참고

> 인덱스 레인지 스캔은 주로 랜덤 I/O, 풀 테이블 스캔은 순차 I/O
> 레인지 스캔보다 풀 테이블 스캔이 빠른 경우가 있음

## 2. 인덱스란?

- 인덱스는 책 맨 끝의 찾아보기로 비유
  - 찾아보기에는 인덱스, 인덱스에 해당하는 페이지는 데이터 파일 위치에 해당(레코드 주소)
- 인덱스는 정렬이 되어 있음
  - 인덱스도 양이 많아지면 찾기가 어려움, 순서대로 정렬되어 있다면 빠르게 찾을 수 있음
- 인덱스는 SortedList와 유사한 구조, 데이터 파일은 ArrayList와 유사
  - 인덱스는 정렬이 되어있고 데이터는 일반적으로는 순차적 특징
  - 인덱스는 저장 과정에서 정렬이 필요하기에 비교적 복잡하고 느림(insert, update, delete)
    - 이미 정렬돼 있어 빨리 원하는 값을 찾을 수 있음
- 검색조건에 모든 칼럼을 인덱스로 생성하는 것은 데이터 저장 성능에 악영향
  - 데이터의 저장 속도를 어디까지 희생할 수 있을지 결정이 필요
- 인덱스의 분류
  - 프라이머리 키
    - 레코드를 대표하는 칼럼의 값, 테이블에서 해당 레코드를 식별
    - 중복 불가, Null 불가
  - 보조 키(세컨더리 인덱스)
    - 프라이머리 키를 제외한 나머지 인덱스
    - 유니크 인덱스는 프라이머리 키와 성격이 비슷, 프라이머리 키의 역할을 대체 가능
- 인덱스 저장 방식의 분류
  - B-Tree 인덱스
    - 오래전에 도입되어 안정적이고 성숙한 알고리즘
    - 칼럼의 값을 변형하지 않고 원래의 값을 이용해 인덱싱
    - MySQL의 위치기반 R-Tree 인덱스는 B-Tree의 응용
  - Hash 인덱스
    - 칼럼의 값을 해시값을 계산하여 인덱싱
    - 값을 변형해서 인덱싱하므로 완전일치 값에 대해서 가능, 범위나 전방 일치는 불가능
- 데이터 중복 허용에 따라 유니크, 논-유니크로 구분
  - 유니크 여부는 옵티마이저에게는 상당히 중요한 문제, 1건의 레코드만 찾으면 된다는 것을 알려주는 효과

> Fractal-Tree, Merge-Tree 인덱스는 어떤 알고리즘일까?

## 3. B-Tree 인덱스

- 인덱싱 알고리즘 가운데 가장 일반적으로 사용, 가장 먼저 도입된 알고리즘
- 가장 범용적인 목적으로 사용

> B+-Tree,  B*-Tree 는 B-Tree와 무엇이 다를까?

### 3.1. 구조 및 특성

- 루트, 브랜치, 리프 노드로 구성
  - 루트 노드
    - 최상위 노드
  - 브랜치 노드
    - 루트 노드도 아니고 리프 노드도 아닌 노드
  - 리프 노드
    - 트리에 가장 말단에 위치, 실제 레코드를 찾아가기 위한 주솟값이 있음
- 실제 데이터는 임의의 순서, 레코드가 삭제되어 빈 공간이 생기면 공강을 재활용하도록 설계
- InnoDB 테이블에서 레코드는 클러스터되어 디스크에 저장, 프라이머리 키 순서로 정렬되어 저장
- 인덱스는 테이블의 키 칼럼만 가지고 있으므로 나머지 칼럼은 레코드에서 찾아야 함
- MyISAM, InnoDB의 차이
  - 세컨더리 인덱슬를 통해 레코드를 찾는 법
    - MyISAM은 세컨더리 인덱스에 물리적인 주소가 있고 InnoDB는 프라이머리 키를 주소처럼 사용(논리적인 주소)
    - InnoDB의 경우 인덱스에 저장된 프라이머리 키 값을 갖고 프라이머리 키 인덱스를 한번 더 검색하고 해당 리프 페이지에 저장된 레코드에 접근

> 클러스터링 인덱스를 참고하자

### 3.2. B-Tree 인덱스 키 추가 및 삭제

- 테이블의 레코드를 저장하거나 변경하는 경우 인덱스 키 추가나 삭제 작업이 동반
- 인덱스를 수정하는 작업은 랜덤하게 디스크를 읽는 작업이 필요
  - 작업의 양이 많다면 상당한 자원을 소모
- InnoDB는 변경해야 할 인덱스 페이지가 버퍼 풀에 있으면 바로 업데이트를 수행
  - 버퍼 풀에 없다면 임시 공간에 저장해 두고 사용자에게 결과를 반환하는 형태로 성능을 향상 (체인지 버퍼)
    - 체인지 버퍼는 백그라운드 스레드에 의해 병합
  - 중복 여부를 체크하는 유니크 인덱스는 체인지 버퍼를 사용할 수 없음

#### 3.2.1. 인덱스 키 추가

- 스토리지 엔진에 따라 즉시 인덱스에 추가되거나 그렇지 않을 수 있음
- 인덱스 추가 절차
  1. B-Tree 상의 적절한 위치를 검색
  2. 저장할 위치를 결정, 리프 노드가 꽉 차서 저장할 수 없을 때는 리프 노드 분리(리프 노드 분리는 상위 브랜치 노드까지 처리의 범위가 넓어짐)
  3. 리프 노드에 저장
- 상대적으로 쓰기 작업에 비용이 높음
  - 작업 비용에 칼럼 수, 칼럼의 크기, 인덱스 칼럼의 특성 등이 영향이 미침
  - 대략적인 비용 계산은 레코드 추가가 1, 인덱스 키를 추가하는 작업 비용을 1.5 정도
    - 인덱스가 3개라면 1 + 4.5(1.5*3) = 5.5 정도로 예측
- MyISAM, MEMORY 스토리지 엔진은 INSERT 문장이 실행되면 즉시 키 값을 B-Tree에 반영
- InnoDB 엔진은 필요하다면 인덱스 키 추가 작업을 지연시켜 나중에 처리 가능
  - 프라이머리 키나 유니크 인덱스와 같이 중복 체크가 필요한 경우는 즉시 반영

#### 3.2.2. 인덱스 키 삭제

- 삭제할 B-Tree 리프 노드를 찾아서 삭제를 마킹
  - 키 공간은 계속 그대로 방치하거나 재활용 가능
- MyISAM, MEMORY 스토리지 엔진은 체인지 버퍼 기능이 없으므로 즉시 인덱스 키에 반영

#### 3.2.3. 인덱스 키 변경

- 인덱스에 해당하는 값에 따라 리프 노드 위치가 결정되므로 단순히 인덱스상의 키 값 변경으로는 불가
- 인덱스 키 값을 변경하는 작업은 기존 인덱스를 삭제한 후 새로운 인덱스 키를 추가
  - InnoDB 스토리지 엔진을 사용하는 테이블에 대해서는 체인지 버퍼를 활용하여 지연처리 가능

#### 3.2.4. 인덱스 키 검색

- 루트, 브랜치, 리프 노드를 거치며 검색을 위한 비교 작업을 수행(트리 탐색)
- SELECT 뿐 아니라 UPDATE, DELETE를 처리하기 위한 레코드 검색에서도 사용
- B-Tree 인덱스는 완전 일치, 앞부분만 일치하는 경우 사용 가능
  - 키 값의 뒷부분만 검색하는 용도로는 사용 불가
- 인덱스 키 값에 변형이 가해진 후 비교하는 경우 B-Tree의 빠른 검색을 사용 불가
  - 이미 변형된 B-Tree 인덱스에 존재하는 값이 아니면 불가
  - 추가적인 함수, 연산을 통한 결과를 통해 정렬 및 검색할 경우 인덱스 사용 불가
- 검색을 수행한 인덱스를 잠근 후 테이블의 레코드를 잠그는 방식으로 구현
  - 적절한 인덱스가 없으면 불필요하게 많은 인덱스를 잠금

### 3.3. B-Tree 인덱스 사용에 영향을 미치는 요소

#### 3.3.1. 인덱스 키 값의 크기

- InnoDB 스토리지 엔진은 디스크에 데이터를 저장하는 기본 단위를 페이지 또는 블록라고 함
- 페이지는 InnoDB 스토리지 엔진의 버퍼 풀에서 데이터를 버퍼링하는 기본 단위, 인덱스도 페이지 단위로 관리
- B-Tree는 자식 노드의 개수가 가변적, 인덱스의 페이지 크기와 키 값의 크기에 따라 결정
  - InnoDB 스토리지 엔진의 페이지 크기를 innodb_page_size를 통해 조절 가능
- 인덱스 키 값이 커지면 단인 인덱스 페이지에 있는 인덱스의 수가 적어짐, 적어진 인덱스 페이지로 인해 SELECT 1번으로 해결할 문제를 디스크 접근 횟수가 늘어남
- InnoDB 버퍼 풀, MyISAM 키 캐시 영역은 크기가 제한적, 레코드를 위한 인덱스 크기가 거치면 메모리에 캐시할 레코드 수가 적어짐

#### 3.3.2. B-Tree 깊이

- 중요한 요소이나 제어할 방법이 없음
- 인덱스 키 값의 크기가 커지면 커질수록 하나의 인덱스 페이지가 담을 수 있는 인덱스 키 값의 개수가 적어짐
  - 같은 레코드 건수라 하더라도 B-Tree의 깊이가 깊어짐
- 실제 B-Tree의 깊이가 5단계 이상까지 깊어지는 경우는 흔치 않음
- 인덱스 키 값을 작게할 수록 B-Tree 깊이가 작아짐`

#### 3.3.3. 선택도(기수성)

- 모든 인덱스 키 값 가운데 유니크한 값의 수를 의미
- 인덱스 키 값에서 중복된 값이 많아지면 많아질수록 기수성은 낮아지고 동시에 선택도도 떨어짐
- MySQL 인덱스의 통계 정보(유니크한 값 개수)를 관리, 인덱스로 추가되지 않은 칼럼은 기수성과 무관
- 인덱스로 작업 범위에 대해 최대한 많은 건수를 제외하는 것이 효율적

#### 3.3.4. 읽어야 하는 레코드 건수

- 인덱스를 통해 테이블의 레코드를 읽는 것은 인덱스를 사용하지 않는 것 보다 높은 비용이 발생
- 인덱스를 이용한 읽기의 손익 분기점이 얼마인지 판단이 필요, 일반적으로 DBMS의 옵티마이저가 판단
  - 인덱스를 통해 레코드를 읽는 것이 테이블에서 직접 1건을 읽는 것보다 4~5배 정도 비용이 더 든다고 예측
  - 전체 테이블 레코드의 20~25%를 넘어서면 인덱스를 이용하지 않고 테이블을 풀 스캔하여 필터링하는 방식이 효율적

> 힌트를 통해서 읽을 경우에 풀 스캔을 무력화 할 수 있을까?

### 3.4. B-Tree 인덱스를 통한 데이터 읽기

- 어떤 경우에 인덱스 사용을 유도할지 못할지 판단이 중요

> explain 을 통해 얻을 수 있는 정보에 대해 정리해보자

#### 3.4.1 인덱스 레인지 스캔

- 해당 단원에서는 인덱스를 통해 레코드를 한 건만 읽는 경우와 한 건 이상을 읽는 경우를 포함
- 레인지 스캔은 검색해야 할 인덱스의 범위가 결정됐을 때 사용
- B-Tree의 필요한 영역을 스캔을 위한 필요 작업 (p231, p232 그림 참고)
  - 루트 노드에서부터 비교를 시작, 브랜치 노드를 거쳐 리프 노드까지 찾아들어가 레코드의 시작 지점을 찾음
  - 시작 위치에서 리프 노드의 레코드만 순서대로 읽음 (인덱스 스캔이라고 함)
    - 인덱스를 순서대로 스캔할 때 정순 또는 역순으로 정렬된 상태로 레코드를 가져옴
      - 추가적인 정렬과정이 있는 것이 아니라 인덱스 자체의 정렬 특성 때문에 자동적인 부분
  - 스캔하다가 현재의 리프 노드 그룹을 다 읽으면 노드 간의 링크를 이용해 다음 리프 노드 그룹으로 이동
  - 최종적으로 스캔 종료 지점까지 다다르면 지금까지 읽은 레코드를 사용자에게 반환하고 쿼리 종료
- 실제 데이터 파일의 레코드를 읽기
  - 인덱스의 리프 노드에서 검색 조건에 일치하는 데이터 파일에서 레코드를 읽어오는 과정이 필요
  - 레코드 한 건 한 건 단위로 랜덤 I/O가 한 번씩 발생
  - 인덱스를 통해 데이터 레코드를 읽는 작업은 비용이 많이 발생
    - 읽어야 할 데이터 레코드가 20~25%를 넘으면 인덱스를 통한 읽기보다 테이블의 데이터를 직접 처리하는 것이 더 효율적인 처리 방식
- 인덱스 레인지 스캔의 과정
  - 인덱스에서 조건을 만족하는 값이 저장된 위치 탐색(인덱스 탐색)
  - 탐색된 위치로부터 필요한 만큼 인덱스를 차례대로 읽기(인덱스 스캔)
  - 읽은 들인 인덱스 키와 레코드 주소를 이용해 레코드가 저장된 페이지를 가져오고, 최종적으로 레코드를 읽음

> 읽어야 할 데이터 레코드가 20~25%를 넘을 경우 인덱스를 통하지 않는 것이 더 빠른 이유에 대해 다시 한번 생각해보자

> 커버링 인덱스란 ?
>> 쿼리의 모든 항목이 인덱스 컬럼으로 이루어져 있는 경우, 인덱스만으로 데이터를 추출

#### 3.4.2 인덱스 풀 스캔

- 인덱스 레인지 스캔과는 달리 인덱스의 처음부터 끝까지 모두 읽는 방식
- 대표적으로 쿼리의 조건절에 사용된 칼럼이 인덱스의 첫 번째 칼럼이 아닌 경우 인덱스 풀 스캔 방식 사용
- 일반적으로 인덱스의 크기는 테이블 크기보다 작으므로 테이블 풀 스캔보다는 인덱스 풀 스캔이 효율적
- 인덱스 리프 노드의 제일 앞 또는 제일 뒤로 이동한 후, 리프 노드를 연결하는 링크드 리스트를 따라서 끝까지 스캔
- 레인지 스캔보다는 느리지만 테이블 풀 스캔보다는 효율적 (디스크 I/O를 줄일 수 있음)

#### 3.4.3. 루스 인덱스 스캔

- 오라클과 같은 DBMS에서의 "인덱스 스킵 스캔"과 작동 방식이 비슷
- 일반적으로 GROUP BY 또는 집합 함수 가운데 MAX() 또는 MIN() 함수에 대해 최적화하는 경우 사용
- 조건에 만족하지 않는 레코드는 무시하고 다음 레코드로 이동

#### 3.4.4. 인덱스 스킵 스캔

- `optimizer_switch='skip_scan=off'` 를 통해 활성화 및 비활성화 할 수 있음
- where 조건에 인덱스로 주어진 칼럼을 주지 않으면 해당 칼럼의 유니크한 값을 모두 조회해서 주어진 쿼리에 추가해 다시 실행하는 형태로 처리
  - 인덱스를 비효율적으로 사용하는 것임
  - 선행 칼럼의 유니크한 값의 개수가 적어야 좋음
    - 유니크한 값이 많으면 스캔해야 할 시작 지점을 검색하는 작업이 많이 필요
  - 쿼리가 인덱스에 존재하는 칼럼만으로 처리 가능해야 함(커버링 인덱스)
    - 해당 부분은 옵티마이저가 개선되면 충분히 해결이 가능할 것 같음

### 3.5. 다중 칼럼 인덱스

- 인덱스의 두 번째 칼럼은 첫 번째 칼럼에 의존해서 정렬
  - 두 번째 칼럼은 첫 번째 칼럼이 똑같은 레코드에서만 의미가 있음
  
### 3.6. B-Tree 인덱스의 정렬 및 스캔 방향

- 인덱스의 키  값은 항상 오름차순이거나 내림차순으로 정렬되어 저장

#### 3.6.1. 인덱스의 정렬

- v5.7 버전까지는 정렬 순서를  혼합해서 인덱스를 생성할 수 없음
  - 인덱스 생성 시, 명령어는 정상적이으로 처리되지만 이는 상위 버전과의 호환성을 위해 처리만 정상이고 내부적으로 정렬되지 않음
- v8.0 부터는 순서를 혼합한 인덱스도 생성 가능

##### 3.6.1.1. 인덱스 스캔 방향

- 오름차순, 내림차순으로 정렬 후 `LIMIT 1` 조회할 경우 인덱스 정렬의 역순으로 읽어 조회
- 인덱스 생성 시점에 오름차순 또는 내림차순으로 정렬이 결정되지만 사용하는 시점에 인덱스 읽는 방향에 따라 다른 정렬 효과를 얻을 수 있음

##### 3.6.1.2. 내림차순 인덱스

- 실제 내림차순인지 오름차순인지와 관계없이 인덱스를 읽는 순서만 변경해서 해결 가능
- 그러나 생각과 다르게 실제로는 정렬에 따라 조회 성능이 달라짐
  - 페이지 잠금이 인덱스 정순 스캔에 적합한 구조이기 때문
  - 페이지 내에서 인덱스 레코드가 단방향으로만 연결된 구조이기 때문
- 검색이 자주되는 정렬로 동일한 기준을 갖는 것이 성능상 이득

### 3.7. B-Tree 인덱스의 가용성과 효율성

#### 3.7.1. 비교 조건의 종류와  효율성

- 인덱스 생성 시, 칼럼의 순서에 따라 쿼리의 성능이 달라짐
- 칼럼의 순서대로 많은 데이터가 필터링이 되면 성능이 좋아짐
  - 카디널리티가 높은 순서대로 인덱스를 걸어주면 효율적
  
#### 3.7.2. 인덱스의 가용성

- `LIKE '%mer'` 와 같이 칼럼에 저장된 값의 왼쪽부터 비교할 경우 왼쪽이 고정되지 않았기 때문에 인덱스 레인지 스캔을 사용할 수 없음
- 다중 인덱스에서 첫 번째 칼럼의 조건이 없는 경우도 인덱스를 효율적으로 사용할 수 없음

#### 3.7.3. 가용성과 효율성 판단

> 쿼리 조건으로 여러가지 케이스를 보며 가용성과 효율성을 참고하자

### 3.7.3. 가용성과 효율성 판단

## 4. R-Tree 인덱스

- 공간 인덱스는 R-Tree 인덱스 알고리즘을 이용해 2차원 데이터를 인덱싱하고 검색 목적
- 기본적인 내부 메커니즘은 B-Tree와 흡사, B-Tree는 인덱스를 1차원의 스칼라 값, B-Tree 인덱스는 2차원의 공간 개념 값
- MySQL 공간 확장에는 다음과 같이 크게 세가지 기능 포함
  - 공간 데이터를 저장할 수 있는 데이터 타입
  - 공간 데이터의 검색을 위한 공간 인덱스(R-Tree 알고리즘)
  - 공간 데이터의 연산 함수(거리 또는 포함 관계의 처리)

### 4.1. 구조 및 특성

- 여러가지 기하학적 도형 정보를 관리할 수 있는 데이터 타입을 제공
  - POINT, LINE, POLYGON, GEOMETRY 
  - GEOMETRY 타입은 나머지 3개 타입의 슈퍼 타입, POINT, LINE, POLYGON 객체를 모두 조정 가능
- MBR(Minimum Bounding Rectangle)으로 도형을 감싸는 최소 크기의 사각형을 통해 포함 관계를 B-Tree 형태로 구현한 인덱스가 R-Tree 인덱스

> MBR을 활용한 인덱스 구성에 대한 자세한 내용은 해당 단원을 참고

### 4.2. R-Tree 인덱스의 용도

- "현자 사용자의 위치로부터 반경 5km 이내의 음식점 검색" 등과 같은 검색에 사용 가능

> 인덱스를 사용하는 자세한 예시는 해당 단원을 참고

## 5. 전문 검색 인덱스

- MySQL의 B-Tree 인덱스는 실제 칼럼의 값이 1MB이더라도 전체를 키로 사용하는 것이 아님
  - InnoDB는 3072 바이트, MyISAM 1000바이트를 사용
- B-Tree 인덱스의 특성에서도 보면 전체 일치 또는 좌측 일치와 같은 검색만 가능
- 문서를 검색하는 전문(Full-Text) 검색에는 일반적인 B-Tree 인덱스를 사용할 수 없음
- 문서 전체에 분석과 검색을 위한 전문 검색(Full Text search) 인덱스가 있음

### 5.1. 인덱스 알고리즘

- 목적은 검색하게 될 키워드를 분석, 빠른 검색용으로 사용할 수 있게 인덱스를 구축
- 키워드의 분석 및 인덱스 구축 방법에는 여러가지가 있을 수 있음
  - 크게 어근 분석과 n-gram 분석 알고리즘으로 구분

#### 5.1.1. 어근 분석 알고리즘

- MySQL 서버의 전문 검색 인덱스는 두가지 중요한 과정을 거쳐서 색인 작업 수행
  - 불용어(Stop Word) 처리
  - 어근 분석(Streaming)
- 불용어 처리
  - 검색에 별 가치가 없는 단어를 필터링해서 제거하는 작업
  - 불용어의 개수는 많지 않기 때문에 알고리즘을 코드에 상수로 정의해서 사용하는 경우가 많음
  - 현재 MySQL은 소스코드에 정의돼 있지만, 이를 무시하고 사용자가 별도로 불용어 정의 가능
- 어근 분석
  - MySQL 서버에서는 오픈 소스 형태소 분석 라이브러리인 MeCab을 플로그인 형태로 지원
    - 한글이나 일본어의 경우 영어와 같이 단어의 변형 자체는 거의 없기 때문에 어근 분석보다는 문장의 형태소 분석해서 명사와 조사를 구분하는 기능이 더 중요한 편
    - 서구권 언어를 위한 형태소 분석기는 MongoDB에서 사용되는 Snowball이라는 오픈소스가 있음
    - 중요한 것은 각 국가의 언어가 서로 문법이 다르고 다른 방식으로 발전해왔기 때문에 형태소 분석, 어근 분석 또한 언어별로 방식이 모두 다름
    - 한국어는 일본어와 많이 비슷하기 때문에 MeCab을 이용해 한글 분석이 가능
    - MeCab을 사용하려면 단어 사전이 필요, 문장 구조 인식을 위해 언어 샘플을 이용한 언어 학습 과정이 필요
      - 이 과정은 상당한 시간이 필요한 작업

#### 5.1.2. n-gram 알고리즘

- MeCab을 위한 형태소 분석은 매우 전문적인 전문 검색 알고리즘
  - 만족할 만한 결과를 위해서는 많은 노력과 시간이 필요, 범용적으로 사용하기 쉽지 않음
- n-gram은 단순히 키워드를 검색해내기 위한 인덱싱 알고리즘
- n-gram은 본문을 무조건 몇 글자씩 잘라서 인덱싱하는 방법
  - 형태소 분석보다는 알고리즘이 단순
  - 국가별 언어에 대한 이해와 준비 작업이 불필요
  - 만들어진 인덱스 크기는 상당히 큰 편
  -  n은 인덱싱할 키워드의 최소 글자 수를 의미, 일반저으로 2글자 단위로 키워드를 쪼개서 인덱싱하는 2-gram 방식을 많이 사용

> 불용어 처리를 통한 n-gram 인덱스 알고리즘에 대한 자세한 예시는 해당 단원을 참고

#### 5.1.3. 불용어 변경 및 삭제

- 이미 설정된 불용어 기준으로 인해 사용자에게 도움이 되기보다는 더 혼란스럽게 하는 기능일 수 있음
- MySQL 서버에 내장된 불용어 대신 사용자가 직접 불용어를 등록하는 방법을 권장

##### 5.1.3.1. 전문 검색 인덱스의 불용어 처리 무시

- 불용어 처리를 무시하는 방법은 두가지가 있음
  - 스토리지 엔진에 관계 없이 MySQL 서버의 모든 전문 검색 인덱스에 대해 불용어를 완전히 제거
    - my.cnf의 `ft_stopword_file` 시스템 변수에 빈 문자열을 설정
    - my.cnf로 설정하기 때문에 설정을 변경하려면 서버 재시작
    - 사용자가 직접 정의한 불용어 목록을 `ft_stopword_file`에 지정
  - InnoDB 스토리지 엔진을 사용하는 테이블의 전문 검색 인덱스에 대해서만 불용어 처리를 무시
    - `innodb_ft_enable_stopword` 시스템 변수를 OFF로 설정, 동적 시스템 변수이므로 MySQL 서버가 실행 중인 상태에서도 변경 가능

##### 5.1.3.2. 사용자 정의 불용어 사용

- MySQL 서버의 내장 불용어를 사용하지 않고, 응용 프로그램의 특성에 맞게 사용자가 직접 정의한 불요어를 사용할 수 있는 방법은 두 가지
  - 사용자가 정의한 불용어 목록을 `ft_stopword_file`에 지정
  - `innodb_ft_server_stopword_table='mydb/my_stopword'`와 같이 설정
    - innodb 스토리지 엔진만 가능, 불용어의 목록을 테이블로 저장하는 방식

> 사용자 정의 불용어를 위한 자세한 테이블 지정 예시는 해당 단원을 참고

### 5.2. 전문 검색 인덱스의 가용성
    
- 전문 검색 인덱스를 사용하려면 반드시 다음 두가지 조건을 갖춰야 함
  - 쿼리 문장이 전문 검색을 위한 문법(MATCH ... AGINST ...)을 사용
  - 테이블이 전문 검색 대상 칼럼에 대해서 전문 인덱스 보유

## 6. 함수 기반 인덱스

- 일반적인 인덱스는 칼럼의 값 일부 또는 전체에 대해서만 인덱스 생성을 허용
- 때로는 칼럼의 값을 변형한 값에 대해 인덱스를 구축해야하는 경구가 있음
- MySQL 서버에서 함수 기반 인덱스를 구현하는 방법은 다음과 같이 두가지로 구분
  - 가상 칼럼을 이용한 인덱스
  - 함수를 이용한 인덱스
- 실제 인덱스의 내부적인 구조 및 유지관리 방법은 B-Tree 인덱스와 동일

### 6.1. 가상 칼럼을 이용한 인덱스

```sql
ALERT TABLE user 
    ADD FULL_NAME VARCHAR(50) AS (CONCAT(first_name, ' ', last_name)) VIRTUAL,
    ADD INDEX ix_fullname (full_name);
```

- `VIRTUAL` 옵션을 통해 가상 칼럼을 추가할 수 있음
- `VIRTUAL`이나 `STORED` 옵션 중 어떤 옵션이든 상관 없이 인덱스 생성 가능
- 가상 칼럼은 테이블에 새로운 칼럼을 추가한 것과 같은 효과
  - 테이블 구조가 변경된다는 단점이 존재

### 6.2. 함수를 이용한 인덱스

- v8.0 버전부터는 함수를 직접 사용하는 인덱스를 생성 가능

```sql
CREATE TABLE user (
    user_id BIGINT,
    first_name VARCHAR(10),
    last_name VARCHAR(10),
    PRIMARY KEY (user_id),
    INDEX ix_fullname ((CONCAT(first_name,. ' ', last_name)))
);
```

- 함수를 이용한 인덱스는 테이블 구조를 변경하지 않음
- 함수 인덱스를 사용하기 위해서는 명시된 표현식이 그대로 사용되어야 함
  - 표현식이 다르면 옵티마이저가 다른 표현식으로 인식하고 함수 기반 인덱스 활용이 불가

`SELECT * FROM user WHERE CONCAT(first_name,. ' ', last_name) = 'Matt Lee';`

- 가상 칼럼, 함수 기반 인덱스는 내부적인 구현이 동일한 것으로 볼 수 있음
  - 성능 차이는 발생하지 않는다는 것을 의미

## 7. 멀티 밸류 인덱스

- 전문 검색 인덱스를 제외한 모든 인덱스는 레코드 1건이 1개의 엔딕스 키 값을 갖음
- 일반적인 RDBMS를 기준으로 이러한 인덱스는 정규화에 위배되는 형태
  - 예시로 근래에 JSON을 지원하며 JSON에 대한 인덱스가 있음

```sql
CREATE TABLE user (
    user_id BIGINT AUTO_INCREMENT PRIMARY KEY,
    first_name VARCHAR(10),
    last_name VARCHAR(10),
    credit_info JSON,
    INDEX ix_creditscores ( (CONCAT(credit_info -> '$.credit_scores' AS UNSIGNED ARRAY)) )
);

INSERT INTO user VALUES (1, 'Matt', 'Lee', '{"credit_scores":[360, 353, 351]}');
SELECT * FROM user WHERE 360 MEMBER OF(credit_info -> '$.credit_scores');
```

## 8. 클러스터링 인덱스

- 클러스터링은 일반적으로 여러 개를 하나로 묶는다는 의미로 주로 사용
- MySQL 서버에서 클러스터링 테이블의 레코드를 비슷한 프라이머리 키를 기준으로 묶어서 저장하는 형태
  - 이는 주로 비슷한 값들을 동시에 조회하는 경우가 많다는 점에서 착안 (데이터 공간 지역성)
- MySQL에서 클러스터링 인덱스는 InnoDB 스토리지 엔진에서만 지원

### 8.1. 클러스터링 인덱스

- 클러스터링 인덱스는 프라미어리 키에 대해서만 적용되는 내용
- 프라이머리 키 값이 비슷한 레코드끼리 묶어서 저장하는 것을 클러스터링 인덱스라고 표현
  - 프라이머리 키 값이 변경된다면 그 레코드의 물리적인 저장 취이가 바뀌어야 한다는 것을 의미
- 일반적으로 InnoDB와 같이 항상 클러스터링 인덱스로 저장되는 테이블은 파이머리 키 기반 검색이 매우 빠름
  - 반면에 레코드 저장이나 프라이머리 키 변경이 상대적으로 느림
- 클러스터링 인덱스 구조 자체는 B-Tree와 비슷, 하지만 리프 노드에 레코드의 모든 칼럼이 같이 저장
- 프라이머리 키가 변경되면 데이터가 변경되고 이는 중요한 요소, 실제로는 변경되는 경우는 거의 없음
- 실제 레코드가 저장되면 저장된 로우 아이디가 있으나 MySQL에서는 사용자에게 노출되지 않음
- 프라이머리 키가 없는 InnoDB 테이블의 클러스터링 구성 방법
  - 아래의 순서대로 작동
    1. 프라이머리 키가 있으면 기본적으로 프라이머리 키를 클러스터링 키로 선택
    2. NOT NULL 옵션의 유니크 인덱스 중에서 첫 번째 인덱스를 클러스터링 키로 선택
    3. 자동으로 유니크한 값을 가지도록 증가하는 칼럼을 내부적으로 추가한 후, 클러스터링 키로 선택
- InnoDB 스토리지 엔진이 적절한 클러스터링 키 후보를 찾지 못하는 경우 내부적으로 레코드의 일련번호 칼럼을 생성
  - 쿼리 문장에 명시적으로 사용할 수 없음, 아무 의미 없는 숫자 값으로 클러스터링 되는 것
  - InnoDB 테이블에서 클러스터링 인덱스는 테이블 당 하나만 가질 수 있기에 가능하다면 명시적으로 생성을 권장

### 8.2. 세컨더리 인덱스에 미치는 영향

- MyISAM, MEMORY 테이블은 처음 저장된 공간에서 절대 이동하지 않음
  - 세컨더리 인덱스와 프라이머리 키와 아무런 차이가 없음
- InnoDB는 프라이머리 키에 의해 클러스터링 인덱스가 결정되고 이를 통해 레코드 위치가 변경
  - 만약 세컨더리 인덱스에서 프라이머리 키 값이 저장되어 있어 프라이머리 키 변경에 따른 오버헤드가 적음
- 세컨더리 인덱스를 통해 프라이머리 키를 통해 최종 레코드를 갖고오는 과정에서 발생하는 성능 저하는 걱정하지 않아도 되는 정도

### 8.3. 클러스터링 인덱스의 장점과 단점

- 일반 프라이머리 키 vs 클러스터링 인덱스 비교 시에 장,단점
  - 장점
    - 프라이머리 키로 검색할 때 처리 성능이 매우 빠름, 특히 프라이머리 키를 범위 검색하는 경우 매우 빠름
    - 테이블의 모든 세컨더리 인덱스가 프라이머리 키를 가지고 있기 때문에 인덱스만으로 처리될 수 있는 경우가 많음(커버링 인덱스)
  - 단점
    - 테이블의 모든 세컨더리 인덱스가 클러스터링 키를 갖기 때문에 클러스터링 키 값의 크기가 클 경우 전체적으로 인덱스의 크기가 커짐
    - 세컨더리 인덱스를 통해 검색할 때 프라이머리 키로 다시 한번 검색해야 하므로 처리 성능이 느림
    - INSERT할 때 프라이머리 키에 의해 레코드의 저장 위치가 결정되기 때문에 처리 성능이 느림
    - 프라이머리 키를 변경할 때 레코드를 DELETE하고 INSERT하는 작업이 필요하기 때문에 처리 성능이 느림
- 온라인 트랜잭션 환경에서는 쓰기와 읽기의 비율이 2:8, 1:9 정도 이기 때문에 느린 쓰기를 감수하고 읽기를 빠르게 유지하는 것은 매우 중요

### 8.4. 클러스터링 테이블 사용 시 주의사항

#### 8.4.1. 클러스터링 인덱스 키의 크기

- 클러스터링 테이블의 경우 모든 세컨더리 인덱스가 프라이머리 키 값을 포함
- 프라이머리 키 값이 커지면 세컨더리 인덱스도 자동으로 증가
- 일반적으로 테이블에 세컨더리 인덱스가 4~5개 정도 생성된다는 것을 고려하면 중요한 문제

#### 8.4.2. 프라이머리 키는 AUTO-INCREMENT 보다는 업무적인 칼럼으로 생성(가능한 경우)

- InnoDB에서 프라이머리 키의 검색은 클러스터링 키이며 매우 빠르게 검색이 가능
- 빠른 검색을 활용하기 위해 업무적으로 자주 검색되는 칼럼에 적용하는 것이 이득
  - 설령 그 칼럼의 크기가 크더라도 업무적으로 해당 레코드를 대표할 수 있다면 권장

#### 8.4.3. 프라이머리 키는 반드시 명시할 것

- 프라이머리 키를 명시하지 않으면 내부적으로 일련번호를 칼럼에 추가
- 내부적으로 추가한 칼럼에 대해서는 전혀 사용할 수 없음
- 이왕이면 사용자가 활용할 수 있는 칼럼으로 명시하는 것이 이득

#### 8.4.4. AUTO-INCREMENT 칼럼을 인조 식별자로 사용할 경우

- 여러 개의 칼럼이 복합으로 프라이머리 키가 만들어지는 경우 세컨더리 인덱스가 필요하지 않다면 그대로 프라이머리 키를 사용하는 것이 좋음
  - 물론 프라이머리 키의 크기가 길어질 때가 있음
- 만약 세컨더리 인덱스도 필요하고 프라이머리 키의 크기도 길다면 AUTO_INCREMENT 칼럼을 추가하고 이를 프라이머리 키로 설정
  - 이렇게 인위적으로 추가된 프라이머리 키를 인조 식별자(Surrogate key)라고 함 

## 9. 유니크 인덱스

- 인덱스라기 보다는 제약 조건에 가까움
- 유니크 인덱스에서 NULL은 특정 값이 아니므로 2개 이상 저장될 수 있음
- 프라이머리 키는 기본적으로 NULL을 허용하지 않는 유키느 속성이 자동으로 부여
  - InnoDB에서 프라이머리 키는 추가적으로 클러스터링 키 역할도 함

### 9.1. 유니크 인덱스와 일반 세컨더리 인덱스의 비교

#### 9.1.1. 인덱스 읽기

- 유니크 인덱스가 일반 인덱스 보다 빠르다는 말은 사실이 아님
- 유니크 하지 않은 인덱스가 느린 이유는 읽어야 할 레코드가 많아서 느린 것이지, 인덱스 자체 특성 때문에 느린 것이 아님
  - 유니크 인덱스는 유니크한 레코드를 보장하기 때문에 읽어야할 레코드가 적기 때문임
- 읽어야 하는 레코드 건수가 같다면 성능상의 차이는 미미

#### 9.1.2. 인덱스 쓰기

- 유니크 인덱스의 키 값을 쓸 때는 중복된 값이 있는지 없는지 체크하는 과정이 한 단계 더 필요
  - 인덱스의 키 값을 쓸 대는 중복된 값이 있는지 없는지 체크하는 과정이 한 단계 더 필요
- 유니크하지 않는 세컨더리 인덱스의 쓰기보다 느림
  - 유니크 인덱스에서 중복된 값을 체크할 때 읽기 잠금을 사용, 쓰기를 할때는 쓰기 잠금을 사용
    - 이러한 과정에서 데드락이 아주 빈번히 발생
- 유니크 인덱스는 반드시 중복 체크를 해야 하므로 작업 자체를 버퍼링하지 못함

### 9.2. 유니크 인덱스 사용 시 주의 사항

- 성능이 좋아질 것으로 생각하고 불필요하게 유니크 인덱스를 생성하지 않는 것이 좋음
- 같은 칼럼 조건을 유니크 인덱스와 일반 인덱스를 각각 중복해서 생성하지 말아야 함
  - 유니크 인덱스도 일반 세컨더리 인덱스와 같은 역할을 동일하게 수행

## 10. 외래키

- MySQL에서 외래키는 InnoDB 스토리지 엔진에서만 생성할 수 있음
- 외래키 제약이 설정되면 자동으로 연관되는 테이블의 칼럼에 인덱스까지 생성
- 외래키가 제거되지 않은 상태에서는 자동으로 생성된 인덱스를 삭제할 수 없음
- InnoDB 외래키 관리에는 중요한 두 가지 특징 존재
  - 테이블의 변경(쓰기 잠금)이 발생하는 경우에만 잠금 경합(잠금 대기)이 발생
  - 외래키와 연관되지 않은 칼럼의 변경은 최대한 잠금 경합(잠금 대기)을 발생시키지 않음
  
### 10.1. 자식 테이블의 변경이 대기하는 경우

- 자식 테이블의 외래 키 칼럼의 변경(INSERT, UPDATE)은 부모 테이블의 확인이 필요
- 부모 테이블의 해당 레코드가 쓰기 잠금이 걸려 있으면 해당 쓰기 잠금이 해제될 때까지 기다림
- 만약 외래키가 아닌 칼럼의 변경은 잠금 확장이 발생하지 않음

### 10.2. 부모 테이블의 변경 작업이 대기하는 경우

- 자식 테이블에서 수정이 일어날 경우 쓰기 잠금이 발생
- 부모 테이블에서 대응되는 부모 레코드를 삭제할 경우 외래키의 특성인 `ON DELETE CASCADE` 때문에 쓰기 잠금이 해제될 때까지 기다려야 함
  - 자식 레코드도 동시에 삭제되는 식으로 작동하기 때문
 
- 데이터베이스에서 외래 키를 물리적으로 생설하려면 이러한 현상으로 인한 잠금 경합까지 고려해 모델링을 진행하는 것을 권장
- 이러한 체크 작업은 연관 테이블에 읽기 잠금을 걸어야 한다는 것, 이렇게 잠금이 다른 테이블로 확장되면 그만큼 전체적으로 쿼리 동시 처리에 영향을 미침