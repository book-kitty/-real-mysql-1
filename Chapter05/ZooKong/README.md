# 트랜잭션과 잠금

- 작업의 완전성을 보장하기 위한 기능
  - 레코드에 대해 여러 커넥션이 변경을 시도를 허용하면 값을 예측하기가 어려움
  - 순서대로 한 시점에는 하나의 커넥션만 변경할 수 있는 역할

## 1. 트랜잭션

### 1.1. MySQL 에서의 트랜잭션

- 논리적인 작업 셋에 하나의 이상의 쿼리가 완전히 적용되거나 완전히 적용되지 않아야 하는 것을 보장
  - MyISAM에서는 쿼리 1~3중에 1, 2번은 성공, 3번은 실패할 경우 1, 2번은 적용되어 있음
    - 이를 부분 업데이트라고 말함, 테이블의 데이터 정합성을 맞추기 어려운 문제
- 애플리케이션 개발에서 고민해야 할 문제를 줄여주는 아주 필수적인 DBMS 기능
  - 트랜잭션을 보장하기 위해 실패로 인한 성공 쿼리를 원복해야 하는 작업이 불필요

### 1.1. 주의 사항

- 트랜잭션의 범위를 최소화 하는 것을 권장

```
1. 처리 시작
 ==> 데이터베이스 커넥션 생성
 ==> 트랜잭션 시작
2. 사용자의 로그인 여부 확인  // 확인을 하는 2, 3번이 아무리 빨리 끝나더라도 트랜잭션에 포함할 필요가 있나?
3. 사용자의 글쓰기 내용의 오류 여부 확인
4. 첨부로 업로드된 파일 확인 및 저장
5. 사용자의 입력 내용을 DBMS에 저장 // DB에 데이터를 저장 시작
6. 첨부 파일 정보를 DBMS에 저장
7. 저장된 내용 또는 기타 정보를 DBMS에 저장 // 이미 저장한 정보를 다시 확인하는데 트랜잭션에 포함할 필요가 있나?
8. 게시물 등록에 대한 알림 메일 발송 // 외부 네트워크 통신이 오래걸리거나 오류가 발생할 수 있음
9. 알림 메일 발송 이력을 DBMS에 저장
 <== 트랜잭션 종료
 <== 데이터베이스 커넥션 반남
10. 처리 완료
```

- 트랜잭션 성능 향상 기법 (트랜잭션 설계 중요)
  1. 빠르게 조회가 가능한 데이터라도 확인을 위한 쿼리는 트랜잭션에 포함하지 않는 것을 권장
  2. 메일 전송, FTP와 같은 네트워크를 통한 작업은 트랜잭션에 포함하지 않는 것을 권장
  3. 이미 저장한 정보를 확인용 조회를 트랜잭션에 포함하지 않는 것을 권장
  4. 전체 흐름에서 크게 벗어나는 내용의 DB 작업은 별도의 트랜잭션으로 관리하는 것을 권장
- 트랜잭션이 오래 걸릴수록 데이터베이스 커넥션 개수가 제한적이여서 여유 커넥션의 개수는 적어짐

## 2. MySQL 엔진의 잠금

- 잠금은 크게 스토리지 엔진, MySQL 엔진 레벨로 분류
- MySQL 엔진 레벨의 잠금은 모든 스토리지 엔진에 영향
- 스토리지 엔진 잠금은 스토리지 엔진 간에 영향을 미치지 않음

### 2.1. 글로벌 락 (GLOBAL LOCK)

- 영향 범위는 MySQL 서버 전체
  - 작업 대상 테이블이나 데이터베이스가 다르더라도 동일하게 영향
  - 글로벌 락은 가급적 사용하지 않는 것을 권장
- 한 세션에서 글로벌 락을 획득할 경우 SELECT를 제외한 대부분의 DDL, DML 문장을 실행하는 동안 대기
- 여러 데이터베이스에 있는 MyISAM, MEMORY 테이블에 대해 mysqldump로 일관된 백업을 받을 때 글로벌 락을 사용
  - mysqldump 명령어는 내부적으로 `FLUSH TABLES WITH READ LOCK`를 실행할 수 있으므로 사용 옵션을 확인
- `FLUSH TABLES WITH READ LOCK` 을 통해 락을 획득할 수 있음
  - 서버에 존재하는 모든 테이블을 닫고 잠금
  - 테이블의 읽기 잠금을 걸기 위해 이미 실행된 테이블, 레코드 쓰기 트랜잭션의 완료를 위해 대기
    - 잠금을 걸기 전에 테이블을 플러시해야 하기 때문에 실행중인 모든 종류의 쿼리가 완료되어야 함
- InnoDB가 사용에 일반화 되었음, 게다가 InnoDB는 트랜잭션을 지원하기 때문에 일관된 데이터 상태를 위해 모든 작업을 멈출 필요가 없음
- MySQL v8.0부터 가벼운 글로벌 락에 필요성이 커짐, Xtrabackup, Enterprise Backup 등과 같은 툴들의 안정적인 실행을 위해 백업 락 도입
  - 특정 세션이 백업 락을 획득하면 다음과 같은 작업이 불가
    - 데이터베이스 및 테이블 등 모든 객체 생성 및 변경, 삭제
    - REPAIR TABLE과 OPTIMIZE TABLE 명령
    - 사용자 관리 및 비밀번호 변경
  - 백업 락은 일반적으로 테이블의 데이터 변경은 허용

> REPAIR TABLE과 OPTIMIZE TABLE 이 무엇일까?

- MySQL 서버 구성은 소스 서버, 레플리카 서버로 구성, 주로 백업은 레플리카 서버에서 실행
- `FLUSH TABLES WITH READ LOCK`를 통한 글로벌 획득 획득할 경우 복제 행위는 백업 만큼 지연
  - 어쩌면 레플리카 서버 백업 도중에 소스 서버에 문제가 생기면 레플리카 서버의 데이터가 최신 상태가 될 때까지 서비스 멈춤
  - Xtrabackup, Enterprise Backup 투를은 복제가 진행되는 상태에서 일관된 백업 가능, 백업 도중에 스키마 변경이되면 백업 실패
  - 이러한 문제로 백업 락 도입, DDL 명령이 실행되면 백업 실패를 막기 위해 복제를 일시 중지

> 소스 서버에 문제가 생기면 왜 레플리카 서버의 데이터가 최신 상태가 될 때까지 서비스가 멈출수 있다고 했을까?

### 2.2. 테이블 락 (TABLE LOCK)

- 영향 범위는 개별 테이블
  - 명시적, 묵시적으로 특정 테이블의 락 획득 가능
    - 명시적, `LOCK TABLES table_name [READ | WRITE]` 명령을 통해 가능, `UNLOCK TABLES`를 통해 반납(해제)
      - 테이블을 잠그는 작업은 글로벌 락과 동일하게 온라인 작업에 상당한 영향, 특별한 상황이 아니면 사용할 필요가 거의 없음
      - MyISAM, InnoDB 엔진을 사용하는 테이블에 락을 획득 가능
    - 묵시적, MyISAM, MEMORY 테이블 데이터를 변경하는 쿼리를 실행하면 발생, 데이터 변경 후에 즉시 잠금 해제
    - InnoDB 테이블은 스토리지 엔진 차원에서 레코드 기반의 잠금을 제공, 묵시적인 테으빌 락이 설정되지 않음
      - 정확히는 테이블 락이 설정되지만 대부분의 데이터 변경(DML) 쿼리에서는 무시, 스키마를 변경하는 쿼리(DDL)의 경우에만 영향

### 2.3. 네임드 락 (NAMED LOCK)

- `GET_LOCK()` 함수를 이용하여 문자열에 대해 잠금을 설정

```
// "mylock" 이라는 문자열 잠금 획득
// 이미 잠금을 사용 중이면 2초 대기, 2초 이후 자동 잠금 해제
mysql> SELECT GET_LOCK('mylock', 2);

// "mylock"이라는 문자열에 대해 잠금 확인
mysql> SELECT IF_FREE_LOCK('mylock');

// "mylock"이라는 문자열에 대해 획득했던 잠금 반납
mysql> select RELEASE_LOCK('mysql');

// 위의 3개 함수 모두 정상적으로 성공하면 1, 아니면 null, 0 반환
```

- 데이터베이스 1대에 5대의 웹 서버가 접속해서 특정 정보를 동기화해야 하는 경우 용이
  - 각 프로그램의 실행 시간을 분산하거나 프로그램끼리 동기화 하는 경우

### 2.4. 메타데이터 락 (METADATA LOCK)

- 데이터베이스 객체의 이름이나 구조를 변경하는 경우 획득하는 잠금
- 명시적으로 획득하건 해제하는 락이 아님
  - `RENAME TABLE tab_a TO tab_b` 같이 테이블 이름을 변경하는 경우 자동 획득
    - 원본 이름과 변경될 이름 두개 모두 한꺼번에 잠금
    - 실시간으로 테이블 변경의 경우 `RENAME TABLE rank TO rank_backup, rank_new TO rank;` 를 활용하면 좋음
      - 2개로 분리해서 실행할 경우 rank 테이블을 찾을 수 없다는 오류가 순간 생길 수 있음
- 로그성 테이블에 대한 DDL 적용
  - Online DDL
    - 시간이 너무 오래 걸리는 경우가 발생할 수 있음, Undo log의 증가, DDL 실행 동안의 누적된 Online DDL 버퍼의 크기 등 고려해야 함
    - DDL은 단일 스레드로 작동하는 것도 많은 시간이 소모되는 이유
  - 테이블 교체
    - 신규 테이블 생성, id 값을 범위별로 나눠서 여러 개의 스레드로 빠르게 복사, 최대한 최근까지 복사
      - "남은 데이터 복사" 하는 시간 동안 테이블의 잠금으로 인해 INSERT를 할 수 없기에 최대한 최근까지 하는 것이 좋음
    - RENAME TABLE 명령으로 응용 프로그램의 중단 없이 실행

> Online DDL 버퍼의 크기란 무엇일까?

## 3. InnoDB 스토리지 엔진 잠금

- 내부에 레코드 기반의 잠금 방식 탑재
- 레코드 기반의 잠금이기에 MyISAM 보다 훨씬 뛰어난 동시성 처리 제공
- 이원화된 InnoDB 스토리지 엔진 잠금 정보는 MySQL 명령을 이용해 접근하기가 까다로움
- 최근에는 트랜잭션, 잠금, 잠금 대기중인 트랜잭션의 목록을 조회할 수 있는 방법이 도입
  - INNODB_TRX, INNODB_LOCKS, INNODB_LOCK_WAITS라는 테이블을 조인해서 조회하면 확인 가능
  - InnoDB의 잠금에 대한 모니터링도 강화되어 Performance Schema를 이용해 내부 잠금에 대한 모니터링 방법도 추가

> 트랜잭션, 잠금, 잠금 대기중인 트랜잭션의 목록을 조회할 수 있는 방법에 대해 더욱 자세히 알아보자.

### 3.1. InnoDB 스토리지 엔진의 잠금

- InnoDB는 레코드 기반의 잠금 기능을 제공
  - 페이지 락이나 테이블 락으로 레벨업되는 경우는 없음

#### 3.1.1. 레코드 락 (Record lock)

- 레코드 자체만을 잠금
- 정확히는 레코드 자체가 아니라 인덱스의 레코드를 잠금
- 인덱스가 하나도 없는 테이블이더라도 내부적으로 자동 생성된 클러스터 인덱스를 이용해 잠금
- 프라이머리 키, 유니크 인덱스에 의한 변경 작업은 레코드 자체만 잠금

> 인덱스가 하나도 없는 테이블에 대해 인덱스 잠금을 하는 방법에 대해 자세히 알아보자.

- 보조 인덱스를 이용한 변경 작업은 넥스트 키 락(Next key lock), 갭 락(Gap lock)을 사용

#### 3.1.2. 갭 락(Gap lock)

- 레코드 자체가 아니라 레코드와 바로 인접한 레코드 사이의 간격만을 잠금
- 레코드와 레코드 사이의 간격에 새로운 레코드가 생성(INSERT)되는 것을 제어
- 넥스트 키 락(Next key lock)의 일부로 자주 사용

#### 3.1.3. 넥스트 키 락(Next key lock)

- 레코드 락과 갭 락을 합쳐 놓은 형태
- STATEMENT 포맷의 바이너리 로그를 사용하는 MySQL 서버에는 REPEATABLE READ 격리 수준을 사용해야 함
- innodb_locks_unsafe_for_binlog 시스템 변수가 비활성화(0)되면 변경을 위해 검색하는 레코드에는 넥스트 키 락 잠금
- InnoDB의 갭 락이나 넥스트 키 락은 바이너리 로그에 기록되는 쿼리가 레플리카 서버에서 실행될 때 소스 서버에서 만들어 낸 결과와 동일한 결과를 보장하는 것이 주목적
- 바이너리 로그 포맷을 ROW 형태로 바꿔서 넥스트 키 락이나 갭 락을 죽이는 것을 권장
  - 의외로 넥스트 키 락과 갭 락으로 인해 데드락이 발생, 트랜잭션의 대기가 자주 발생

> 갭 락, 넥스트 키 락이 레플리카 서버의 동일한 결과를 만들어내는 과정을 상세히 알아보자.

> MySQL의 바이너리 로그에 대해 자세히 알아보자.

#### 3.1.4. 자동 증가 락

- AUTO_INCREAMENT 락이라고 하는 테이블 수준의 잠금
- 명시적으로 락을 획득하고 해제하는 방법은 없음
- 아주 짧은 시간동안 걸렸다가 해제되는 잠금이라 대부분의 경우 문제가 되지 않음
- INSERT, REPLACE 쿼리 문장과 같이 새로운 레코드를 저장하는 쿼리에만 필요
  - `REPLACE INTO ...` : 최초 입수된 레코드가 삭제되고, 신규 레코드가 INSERT, AUTO_INCREMENT의 값이 변경
- 트랜잭션과 관계없이 순간만 락이 걸렸다가 즉시 해제
- AUTO_INCREAMENT 락은 테이블에 하나만 존재, INSERT가 동시에 수행되면 하나는 대기
- AUTO_INCREAMENT 칼럼에 명시적으로 값을 설정더라도 자동 증가 락을 수행
- MySQL v5.1 이상부터 자동 락에 대한 작동 방식 변경 가능, innodb_autonic_lock_mode를 통해 변경
  - innodb_autoinc_lock_mode = 0
    - 위에서 설명한 잠금 방식
  - innodb_autoinc_lock_mode = 1
    - INSERT 레코드의 건수를 정확히 예측 가능할 때, 자동 증가 락을 사용하지 않고 가볍고 빠른 래치(뮤텍스)를 이용
    - 자동 증가 값을 한번에 할당 받아서 사용하며 자동 증가 값이 누락되지 않음, 연속 모드라고도 함
    - `SELECT ... INSERT` 와 같이 레코드 수를 예측하기 힘들 경우  `innodb_autoinc_lock_mode = 0`와 같음
  - innodb_autoinc_lock_mode = 2
    - 절대 자동 락을 걸지 않고 경량화된 래치(뮤텍스)를 사용
    - 하나의 INSERT 되는 문장이라고 하더라도 연속된 자동 증가 값을 보장하지 않음, 오로지 유니크한 값만 보장
    - 대량 `SELECT ... INSERT` 중에 다른 INSERT를 수행ㄱ가능, 동시 처리 성능이 높음
    - STATEMNET 포맷 바이너리 로그를 사용하는 복제에서는 소스 서버와 레플리카 서버의 자동 증가 값이 달라질 수도 있음
- MySQL v5.7 까지는 `innodb_autoinc_lock_mode = 1` 기본, v8.0 이상은 `innodb_autoinc_lock_mode = 2`가 기본

> 자동 증가 락과 래치(뮤텍스)의 차이가 무엇일까?

> JPA에서 한번에 AUTO_INCREAMENT를 갖고 오는 행위는 성능상 이점이 있을까?

> `innodb_autoinc_lock_mode = 2`의 경우 연속된 자동 증가 값을 보장하지 않는 다는 것은 무슨 의미일까?

> STATEMNET 포맷 바이너리 로그를 사용하는 복제에서는 소스 서버와 레플리카 서버의 자동 증가 값이 달라질 수 있는 이유가 무엇일까?

### 3.2. 인덱스와 잠금

- 변경해야 할 레코드를 찾기 위해 검색한 인덱스의 레코드를 모두 락

```
// test1만 index가 걸려 있음
mysql> UPDATE ??? SET date = NOW() WHERE test1 = 'A' AND test2 = 'B'
```

- 데이터 변경을 위해 검색 조건으로 test1, test2 가 존재
- test2는 인덱스가 없기 때문에 test1 인덱스 값에 해당하는 'A' 인 레코드는 모두 락
- UPDATE 작업을 위한 적절한 인덱스가 없다면 각 클라이언트 간의 동시성이 상당히 떨어져서 다른 클라이언트는 테이블에 대해 대기하는 상황이 발생할 수 있음
- 테이블에 인덱스가 하나도 없다면 풀 스캔을 해야하기 때문에 테이블에 있는 모든 레코드를 락

> 인덱스 조건에 의해 락의 범위가 정해진다면 데이터 변경시에 최소의 락이 걸리기 위해 적은 범위의 index를 선택하는 것이 유리할 것 같음

### 3.3. 레코드 수준의 잠금 확인 및 해제

- 레코드 각각에 잠금이 걸리므로 자주 사용되지 않으면 발견하기 어려움
- v5.1 부터 레코드 잠금과 잠금 대기에 대한 조회 가능
  - INNODB_TRX, INNODB_LOCKS, INNODB_LOCK_WAITS라는 테이블을 통해 확인

> 잠금과 잠금 대기 확인하는 방법은 해당 단원을 확인하자

## 4. MySQL의 격리 수준

- 트랜잭션의 격리 수준이란 여러 트랜잭션이 동시에 처리될 경우 다른 트랜잭션에서 변경하거나 조회하는 데이터를 볼 수 있게 허용할지 말지를 결정
- MySQL 에서는 REPEATABLE READ, Oracle 에서는 READ COMMITTED가 기본 값
- 일반적인 온라인 서비스 용도의 데이터베이스는 READ COMMITTED, REPEATABLE READ 중 하나를 사용
- 격리 수준이 높아질수록 동시 처리 성능도 떨어지는 것이 일반적

### 4.1. READ UNCOMMITTED

- 일반적인 데이터베이스에서는 거의 사용하지 않음
- Dirty read가 발생함, 데이터 변경을 목적으로 특정 트랜잭션이 시작되고 끝나지 않았음에도 다른 트랜잭션에서 볼 수 있는 현상
  - 장애가 발생하여 변경 목적인 트랜잭션이 Rollback을 하게되면 존재하지 않은 데이터를 읽은 결과
- RDBMS 표준에서는 트랜잭션의 격리 수준으로 인정하지 않을 정도로 정합성 문제가 많은 격리 수준  

### 4.2. READ COMMITTED

- COMMIT이 완료된 데이터만 접근 가능
  - Undo log를 활용하여 COMMIT이 전의 데이터를 보관하고 해당 데이터를 조회 
- 최소 해당 격리 수준을 권장
- Dirty read가 발생하지 않음, 대신 NON-REPEATABLE READ 부정합 문제가 있음
  - A 트랜잭션에서 SELECT를 두번 실행
  - B 트랜잭션에서 A 트랜잭션의 SELECT 사이에 INSERT를 COMMIT
  - A 트랜잭션에서 두번째 SELECT는 INSERT된 데이터 접근 가능
- 트랜잭션 수행 중에 다른 트랜잭션에 의한 COMMIT 완료가 일어나면 데이터 접근 범위에 대한 일관성이 떨어짐

### 4.3. REPEATABLE READ

- SQL-92, SQL-99 표준에 따르면 PHANTOM READ가 발생할 수 있지만, InnoDB 특성 때문에 PHANTOM READ가 발생하지 않음
  - InnoDB 스토리지 엔진에서 갭 락, 넥스트 키 락 덕분에서 발생하지 않음 
- 바이너리 로그를 가진 MySQL 서버에서는 해당 격리 수준 이상을 사용해야 함
- MVCC를 위해 Undo 영역에 백업된 이전 데이터를 이용해 트랜잭션 내에서 동일한 결과를 보장
- Undo 영역에 백업된 레코드는 변경을 발생시킨 트랜잭션 번호를 포함, Undo 영역은 InnoDB 스토리지 엔진이 불필요하다고 판단하는 시점에 주기적으로 삭제
- 트랜잭션 번호가 작은 Undo log를 활용하여 일관성 유지, 하나의 레코드에 대해 백업이 하나 이상 존재 가능
- 한 사용자가 장시간 트랜잭션을 종료하지 않으면 Undo log 영역에 백업된 데이터가 무한정 커질 수 있으며 MySQL 서버의 처리 성능 저하

> SQL-92, SQL-99 표준이란 무엇일까?

> 왜 바이너리 로그인 경우 REPEATABLE READ 이상의 격리 수준을 사용해야 할까?

> Undo 레코드에는 왜 잠금을 걸 수 없을까? (p183 을 자세히 다시 보자)

### 4.4. SERIALIZABLE

- 동시성이 중요한 데이터베이스에서는 거의 사용하지 않음
- 읽기 작업 조차 공유 잠금(읽기 잠금)을 획득해야 하며 다른 트랜잭션은 그러한 레코드를 변경하지 못함
  - 즉, 한 트랜잭션에서 읽고 쓰는 레코드를 다른 트랜잭션에서 절대 접근 불가 
- PHANTOM READ가 발생하지 않음
- InnoDB 테이블에서 기본적으로 아래와 같음
  - Non-locking consistent read(잠금 필요 없는 일관된 읽기) 에서는 아무런 레코드를 잠금하지 않음
    - `INSERT .. SELECT`, `CREATE TABLE ... AS SELECT` .. 등 
  - 그러나 SERIALIZABLE 격리 수준에서는 효력이 떨어짐