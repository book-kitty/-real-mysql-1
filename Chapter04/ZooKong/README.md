# 아키텍처

## MySQL 엔진 아키텍처

### `전체 구조`

- MySQL 서버는 MySQL 엔진과 스토리지 엔진으로 구분
  - MySQL은 일반 상용 RDBMS와 같이 대부분 프로그래밍 언어로부터 접근 지원 
  - MySQL 엔진
    - 사람의 머리 역할과 흡사
    - 요청을 처리하는 커넥션 핸들러, SQL 파서 및 전처리기, 옴티마이저 등으로 구성 
  - 스토리지 엔진
    - 손과 발의 역할과 흡사
    - 실제 데이터를 디스크 스토리지에 저장하거나 읽어오는 부분을 전담
    - MySQL 엔진은 하나이지만 스토리지 엔진은 여러개 동시에 사용 가능
      - ``` mysql> CREATE TABLE test_table (…) ENGINE=INNODB; ```
      - test_table 테이블에 대해 DML 요청 시에 InnoDB 스토리지 엔진이 처리 담당
  - 핸들러 API
    - MySQL 엔진의 쿼리 실행을 위해 스토리지 엔진에게 요청을 함
    - 이러한 요청을 핸들러 요청이라 함, 여기서 사용되는 API를 핸들러 API라고 함
    - 핸들러 API를 통해 얼마나 많은 데이터 작업이 있는지 확인 가능
      - ``` mysql> SHOW GLOBAL STATUS LIKE 'Handler%'; ```

### `스레딩 구조`

- 프로세스 기반이 아닌 스레드 기반으로 작동
- 스레드는 크겍 포그라운드, 백그라운드 스레드로 구분
  - performance_schema DB에 threads 테이블을 통해 실행 중인 스레드 확인 가능
- 백그라운드 스레드의 개수는 서버 설정으로 변경 가능
  - innodb_read_io_threads, innodb_write_io_threads

#### 포그라운드 스레드

- 최소한 MySQL 서버에 접속된 클라언트의 수만큼 존재
- 주로 각 클라이언트가 요청하는 쿼리 문장 처리
- 커넥션을 종료하면 해당 커넥션을 담당하던 스레드는 다시 스레드 캐시로 되돌아 감
  - thread_cache_size에 설정된 값보다 많은 스레드가 있을 경우 스레드를 캐시에 돌려놓지 않고 종료
- 데이터를 MySQL의 데이터 버퍼나 캐시로부터 조회, 없을 경우 직접 디스크의 데이터나 인덱스 파일로부터 데이터를 읽어와 작업 처리
- 디스크 쓰기 작업은 MyISAM 엔진의 경우 포그라운드 스레드가 처리, InnoDB 엔진은 데이터 버퍼나 캐시까지만 포그라운드가 처리 후 디스크 기록은 백그라운드 스레드가 처리
  - MyISAM도 지연된 쓰기가 존재는하나 일반적인 방법은 아님

#### 백그라운드 스레드

- MyISAM는 별로 해당되지는 않지만 InnoDB의 백그라운드 처리 항목
  - 인서트 버퍼를 병합하는 스레드
  - 로그를 디스크로 기록하는 스레드
  - InnoDB 버퍼 풀의 데이터를 디스크에 기록하는 스레드
  - 데이터를 버퍼로 읽어 오는 스레드
  - 잠금이나 데드락을 모니터링하는 스레드
- 주로 읽는 작업은 클라이언트 스레드에서 처리되기 때문에 innodb_read_io_threads 는 많이 설정할 필요가 없음
- 쓰기 작업은 백그라운드에서 많이 처리
- 사용자 요청 처리중에는 데이터 쓰기 작업은 지연 처리가 될 수 있지만 읽기 작업은 절대 지연될 수 없음
  - 일반적으로 DBMS는 쓰기 작업을 버퍼링해서 일괄 처리하는 기능이 탑재, InnoDB도 같은 방식
    - 디스크에 데이터 파일이 적용까지 기다릴 필요가 없음
  - MyISAM는 포그라운드 스레드가 쓰기 작업까지 함께 처리
    - 일반적인 쿼리는 쓰기 버퍼링 기능을 사용할 수 없음

> MyISAM에서 일반적인 쿼리는 쓰기 버퍼링 기능을 사용할 수 없다고 하였는데 그럼 언제 사용할 수 있을까?

### `메모리 할당 및 사용 구조`

- 크게 글로벌, 로컬 메모리 영역으로 구분

#### 글로벌 메모리 영역

- MySQL 서버가 시작되면서 운영체제로부터 할당
  - 정확히 할당된 메모리 확인이 쉽지 않아 시스템 변수로 설정한 만큼 할당받는다고 생각
  
> MySQL 서버의 메모리 할당과 관련된 시스템 변수는 무엇이 있을까?

- 일반적으로 클라언트 스레드의 수와 무관하게 하나의 메모리 공간만 할당
  - 필요에 따라 2개 이상의 메모리 공간을 할당받을 수 있음
  - 대표적인 글로벌 메모리 영역
    - 테이블 캐시
    - InnoDB 버퍼 풀
    - InnoDB 어댑티브 해시 인덱스
    - InnoDB 리두 로그 버퍼

> 2개 이상의 메모리 공간을 할당받을 이유와 상황이 무엇일까?
> InnoDB 언두 로그 버퍼가 있을까?

#### 로컬 메모리 영역 (다시 읽어보기)

- 세션 메모리 영역이라고도 표현
- 클라이언트 스레드가 쿼리를 처리하는데 사용하는 메모리 영역
- 각 클라언트 스레드별로 독립적으로 할당, 공유되지 않음
- 가능성은 희박하지만 MySQL 서버가 메모리 부족으로 멈춰 버릴 수 있음, 그러나 일반적으로 소트 버퍼와 같은 로컬 메모리 영역은 크게 신경쓰지 않음
- 대표적인 로컬 메모리 영역
  - 정렬 버퍼
  - 조인 버퍼
  - 바이너리 로그 캐시
  - 네트워크 버퍼

### ```플러그인 스토리지 엔진 모델```

- 플러그인 모델은 MySQL의 독특한 특징 중 하나
- 스토리지 엔진, 검색어 파서 등에 대해 플러그인해서 사용 가능, 게다가 사용자의 인증을 위한 Native Authentication 등도 모두 플러그인
  - 직접 스토리지 엔진을 개발하는 것도 가능
- 쿼리 실행에 있어서 대부분의 작업이 MySQL 엔진에서 처리, 마지막 "읽기/쓰기" 작업만 스토리지 엔진에서 처리
  - 이는 스토리지 엔진을 만든다 하더라도 전체 기능이 아닌 일부를 개발한다는 의미
- MySQL 엔진이 각 스토리지 엔진에게 데이터를 읽고/쓰기 위해서는 반드시 핸들러를 통해야 함
- 스토리지 엔진이 다르더라도 MySQL의 처리 내용은 대부분 동일, 스토리지 엔진 담당인 읽기/쓰기 영역의 처리만 차이
- 실직적으로 GROUP BY나 ORDER BY 등 복잡한 처리는 MySQL 엔진의 '쿼리 실행기'에서 처리

> GROUP BY나 ORDER BY의 경우 MySQL 엔진 부분에서 제어가 된다면 많은 양의 데이터를 수행하기 위해서는 메모리가 많이 필요하지 않을까?

``` 
# 지원되는 스토리지 엔진 확인
mysql> SHOW ENGINES;
```

- 포함되지 않은 스토리지 엔진을 사용하려면 서버를 다시 빌드(컴파일) 필요
- 적절한 준비만 돼 있다면 플러그인 형태로 빌드된 스토리지 엔진 라이브러리를 다운로드해서 끼워 넣기만 하면 사용 가능
- 플러그인 형태의 스토리지 엔진은 손쉽게 업그레이드 가능

```
# 서버의 플러그인 확인
mysql> SHOW PLUGINS;
```

> 플러그인 형태로 라이브러리를 다운로드해서 끼워 넣으면 사용 가능하다고 하는데.. 적절한 준비는 무슨 준비일까?

### ```컴포넌트```

- 8.0에서 기존 플러그인 아키텍처를 대체하기 위해 컴포넌트 아키텍처 지원
- 기존 플러그인 아키텍처 단점
  - 플러그인은 오직 MySQL 서버와 인터페이스할 수 있고, 플러그인끼리는 통신할 수 없음
  - MySQL 서버의 변수나 함수를 직접 호출하기 때문에 안전하지 않음
  - 상호 의존 관계를 설정할 수 없어서 초기화 어려움
- 비밀번호 검증에 대해 5.7은 플러그인, 8.0은 컴포넌트로 개선
- 컴포넌트도 플러인과 마찬가지로 설치하면 새로운 시스템 변수를 설정해야 할 수 있어 메뉴얼을 확인해야 함
  
> 플로그인과 컴포넌트는 내부적으로 어떤 구조적 차이가 있을까?

### `쿼리 실행 구조`
 
- 쿼리 실행 순서 : 쿼리 파서 -> 전처리기 -> 옵티마이저 -> 실행 엔진(실행기) -> 스토리지 엔진(핸들러)
  - 쿼리 파서
    - 사용자 요청 쿼리를 토큰으로 분리 후 트리 형태 구조로 변환, 파서 트리 생성
    - 쿼리 문장의 기본 문법 오류 검사
  - 전처리기
    - 파서 트리를 기반으로 문장에 구조적 문제점 확인
    - 각 토큰에 대해 테이블 이름, 칼럼 이름, 내장 함수 등의 객체 존재 여부 등 확인
    - 접근 권한 등 확인
  - 옵티마이저
    - 쿼리 문장을 저렴한 비용으로 가장 빠르게 처리할지를 결정
    - DBMS의 두뇌에 해당
  - 실행 엔진
    - 작업 처리 계획대로 각 핸들러에게 요청
    - 결과를 또 다른 핸들러 요청의 입력으로 연결하는 역할 수행
  - 스토리지 엔진(핸들러)
    - MySQL 서버의 가장 밑단에서 실행 엔진의 요청에 따라 데이터를 읽기/쓰기 역할 담당
    - InnoDB 테이블을 조작하는 경우 핸들러가 InnoDB 스토리지 엔진임

### `복제` (16장 읽기)

- 16장 참고

### `쿼리 캐시`

- 빠른 응답을 위해 필요
  - 특히 웹 기반의 응용 프로그램에서 매우 중요한 역할
- 실행 결과를 메모리에 캐시하고 동일 SQL 쿼리에 대해 테이블을 읽지 않고 즉시 결과를 반환
- 쿼리 캐시 단점
  - 테이블 데이터 변경으로 인해 관련 캐시를 삭제, 심각한 동시 처리 성능 저하 유발
  - 많은 버그의 원인 되기도 했음
- 8.0 부터는 쿼리 캐시 기능 및 관련 시스템 변수 모두 제거
- 데이터 변경은 거의 없고 읽기만 하는 서비스는 흔치 않아 실제 큰 도움이 됐던 서비스는 거의 없음, 버그가 더 큰 영향

> 쿼리 캐시의 단점 중에 많은 버그가 존재했다고 하였는데 어떤 이유에서 발생한 것일까?

### `스레드 풀`

- 엔터프라이즈 에디션은 스레드 풀 기능 제공
- 커뮤니티는 Percona Server에 플러그인 형태의 스레드 풀 라이브러리를 설치하여 사용 가능
- 사용자의 요청을 처리하는 스레드 개수를 제한하고 CPU가 제한된 스레드 처리에만 집중하여 서버의 자원 소모를 줄이는 것이 목적
- CPU가 잘 처리해낼 수 있는 수준으로 스레드를 줄여서 빨리 처리하게 하는 것이 핵심
  - CPU 프로세서 친화도를 높이고 불필요한 컨텍스트 스위치를 줄여 오버헤드를 감소
- Percona Server 스레드 풀
  - CPU 코어 개수만큼 스레드 그룹을 생성, thread_pool_size 값을 변경하여 조정 가능
    - CPU 코어 개수와 일치하는 것이 CPU 프로세서 친화도가 증가
  - thread_pool_oversubscribe 시스템 변수로 스레드 풀로 부족할 경우 추가할 스레드를 지정
    - 기본 값으로 3
  - thread_pool_stall_limit 시스템 변수에 설정하는 밀리초를 통해 새로운 스레드를 추가할지 기다릴지 결정
    - 응답 시간에 민감한 서비스라면 적절하게 낮춰야 함
    - 0에 너무 가까운 값이면 스레드 풀을 사용하지 않는 편이 나을 것
  - thread_pool_max_threads 시스템 변수로 전체 스레드 풀에 있는 스레드 개수를 제한
  - 선순위 큐, 후순위 큐
    - 먼저 시작된 트랜잭션 내에 속한 SQL을 빨리 처리해주는 방식으로 순서를 재배치
  
> 트랜잭션 문법은 어떠한 것들이 있을까?

### `트랜잭션 지원 메타 데이터`

- 메타 데이터
  - 테이블 구조 정보, 스토어드 프로그램 등의 정보를 데이터 사전 혹은 메타 데이터라고 함
- MySQL 5.7 까지
  - 테이블 그 구조를 FRM 파일에 저장, 이룹 스토어드 프로그램 또한 파일 기반으로 관리
  - 파일 관리에 있어 트랜잭션을 지원하지 않음
  - 해당 파일 수정 도중에 서버가 종료되면 일관되지 않은 파일로 존재, 이를 "데이터베이스나 테이블이 깨졌다"라 표현
- MySQL 8.0 부터
  - 테이블 구조, 스토어드 프로그램 관련 정보를 모두 InnoDB 테이블에 저장
    - 저장하는 내용에는 시스템 테이블도 포함, 시스템 테이블이란 서버 작동을 위한 기본적인 필요 테이블의 묶음
  - 시스템 테이블과 데이터 사전 정보를 모두 모아서 mysql DB에 저장, mysql DB는 통재로 mysql.ibd라는 테이블 스페이스에 저장
  - 데이터 경로에 존재하는 mysql.ibd 파일과 *.ibd 파일과 함께 주의해야 함
  - 시스템 테이블, 데이터 사전에 대한 수정은 트랜잭션 기반이기에 완전 성공, 완전한 실패로 정리
- 데이터 사전을 저장한 테이블은 테이블 목록에 보이지 않음
  - 사용자가 임의로 수정하지 못하게 화면에 노출하지 않음
- InnoDB 스토리지 인젠 이외에는 메타 정보를 *.sdi 파일로 보관, FRM 파일과 동일한 역할
- ibd2sdi 유틸을 통해 InnoDB 테이블스페이스에서 스키마 정보를 추출 가능

## InnoDB 스토리지 엔진 아키텍처

- InnoDB 스토리지 엔진에 대한 이야기
- InnoDB는 MySQL에서 거의 유일하게 레코드 기반의 잠금을 제공
  - 동시성 처리가 가능하고 안정적이며 성능이 좋음

### `프라이머리 키에 의한 클러스터링`

  - InnoDB의 모든 테이블은 기본적으로 프라이머리키에 의한 클러스터링
  - 모든 세컨더리 인덱스는 레코드 주소가 아닌 프라이머리 키의 값을 논리적인 주소로 사용
  - 프라이머리 키에 대한 레인지 스캔은 상당히 빠름
  - MyISAM 엔진에서
    - 클러스터링 키를 지원하지 않음
    - 프라이머리 키와 세컨더리 인덱스는 구조적으로 차이가 없음
    - 프라이머리 키는 유니크한 세컨더리 인덱스일 뿐
    - 모든 키와 인덱스는 물리적인 레코드 주소 값을 가짐

### `외래키 지원`

  - MyISAM이나 MEMORY 테이블에서는 사용 불가
  - 부모 테이블과 자식 테이블에 해당 칼럼에 인덱스 생성이 필요
  - 변경 시에는 반드시 부모, 자식 테이블에 데이터가 있는지 체크, 잠금이 여러 테이블로 전파, 데드락 발생 확률이 올라감
  - 외래 키가 복잡한 경우 수동으로 데이터를 적재할 때 순서를 지키지 않아 실패할 수 있음
    - foreign_key_checks 시스템 변수를 OFF로 설정하면 외래 키 관계에 대한 체크 작업을 일시적으로 멈춤
      - 글로벌, 세션 변수임, 세션에서만 외래 키 체크 기능을 멈추는 것을 강하게 권장
    - 외래 키 체크를 멈추고 데이터를 변경할 경우 반드시 부모, 자식 테이블 데이터 관계를 일관성 있게 유지시켜줘야 함
      

> 외래 키로 인해 수동 데이터 작업이 실패하는 경우는 어떤 경우일까?

### `MVCC(Multi Version Concurrency Control)`

- 하나의 레코드에 대해 여러 개의 버전이 동시에 관리된다는 의미
- InnoDB는 Undo log를 이용하여 구현
- 일반적으로 레코드 레벨의 트랜잭션을 지원하는 DBMS가 제공하는 기능
- 잠금을 사용하지 않는 일관된 일기를 제공하기 위함
- Update 문장에 의한 내부 로직
  - InnoDB 버퍼 풀에 내용을 반영
  - InnoDB 버퍼풀 변경 내용은 백그라운드 스레드에 의해 기록, 현재 반영 여부는 시점에 따라 다를 수 있음
  - Undo log에 변경 전 값만 로그로 복사
  - 만약 여기서 조회가 발생하면 격리 수준(Isolation level)에 따라 결과가 다름
    - READ_UNCOMMITTED 일 경우 InnoDB 버퍼 풀에 있는 데이터를 조회
    - READ_COMMITTED 이나 그 이상인 경우 변경 전의 Undo log에 있는 데이터를 조회
  - 만약 여기서 COMMIT 명령을 실행하면 더 이상 변경 작업 없이 영구적인 데이터로 만들어버림
    - ROLLBACK을 한다면 Undo 영역 데이터를 다시 InnoDB 버퍼 풀로 복구, Undo 영역의 내용 삭제
    - Undo 영역을 즉시 삭제되는 것은 아니며 필요로 하는 트랜잭션이 없을 때 비로소 삭제
- 예전 데이터의 버전은 무한히 많아질 수 있음
  - 트랜잭션이 길어지면 Undo log에서 관리하는 예전 데이터가 삭제되지 못하고 오랫동안 보관, Undo 영역이 저장되는 시스템 테이블스페이스의 공간도 늘어날 수 있음

### `잠금 없는 일관된 읽기(Non-Lockingg Consistent Read)`

- 격리 수준 SERIALIZABLE 을 제외한다면 INSERT와 연결되지 않는 순수 읽기 작업은 트랜잭션의 변경 작업과 관계없이 항상 잠금을 대기하지 않음
  - 변경되기 전 데이터를 읽기 위해 Undo log를 사용
- 오랜 시간 동안 활성화인 트랜잭션으로 Mysql 서버가 느려지는 경우가 있음
  - 일관된 읽기를 위해 Undo log를 삭제하지 못하게 계속 유지하기 때문에 발생
  - 가능한 한 빨리 ROLLBACK 이나 COMMIT을 완료하는 것이 좋음

### `자동 데드락 감지`

- InnoDB 스토리지 엔진은 내부적으로 잠금이 교착 상태인지 체크
  - 체크를 위해 잠금 대기 목록을 그래프(Wait-For List) 형태로 관리
- 교착 상태에 빠진 트랜잭션을찾아 하나를 강제로 종료
  - Undo log가 상대적으로 적은 트랜잭션이 ROLLBACK 대상
  - 상대적으로 ROLLBACK을 적게 수행해도 되기 때문에 부하가 적음
- innodb_table_locks 시스템 변수를 활성화하면 InnoDB 스토리지 엔진 내부의 레코드, 테이블 레벨의 잠금까지 감지 가능
  - 기본적으로는 MySQL 엔진에서 관리되는 테이블 잠금은 InnoDB 스토리지 엔진은 감지가 불확실함
    - MySQL 엔진에서 테이블 락은 `LOCK TABLES` 명령어로 잠금 가능
- 동시 처리 스레드가 많아지거나 각 트랜잭션이 가진 잠금의 개수가 많아지면 데드락 감지 스레드가 느려짐
  - 데드락 검사를 위해서는 잠금 상태가 변경되지 않도록 잠금 목록이 저장된 리스트에 잠금을 걸고 데드락을 찾음
  - 데드락 스레드가 느려지면 서비스 쿼리를 처리 중인 스레드는 작업을 진행하지 못하고 대기, 결국 서바스에 악 영향
  - innodb_deadlock_detect 시스템 변수를 OFF하면 데드락 감지 스레드는 작동하지 않음
    - 데드락 상황이 발생해도 중재하지 않기 때문에 무한정 대기가 발생할 수 있음
  - innodb_lock_wait_timeout 시스템 변수에 초단위 설정을 통해 데드락 상황에서 일정 시간이 지나면 자동으로 요청이 실패하고 에러 반환
    - 잠금을 설정한 시간동안 획득하지 못하면 쿼리는 실패하고 에러를 반환하는 시스템 변수
  - innodb_deadlock_detect를 OFF 한다면 innodb_lock_wait_timeout 를 50초보다 훨씬 낮은 시간으로 설정할 것을 권장

> innodb_deadlock_detect를 OFF 한다면 innodb_lock_wait_timeout 를 50초보다 훨씬 낮은 시간으로 설정할 것을 권장하는 이유는 무엇일까?

### `자동화된 장애 복구`

- InnoDB는 손실이나 장애로부터 데이터를 복구하는 작업이 자동으로 진행
- InnoDB 스토리지 엔진은 견고해서 데이터 파일이 손상되는 일은 극히 적음
- MySQL과 무관하게 디스크나 서버 하드웨어 이슈로 파일이 손상되는 경우가 있일 수 있음
- 복구될 수 없는 손상이라면 MySQL는 자동 복구를 멈추고 종료
- innodb_force_recovery 시스템 변수를 설정해서 데이터 파일이나 로그 파일의 손상 여부 검사 과정을 선별적으로 진행 가능 [forcing-innodb-recovery](https://dev.mysql.com/doc/refman/8.0/en/forcing-innodb-recovery.html)
  - 기본 값은 0
  - innodb_force_recovery의 값이 커질수록 심각한 상황을 뜻함
  - 0이 아닌 복구 모드에서는 SELECT 이외의 쿼리는 수행할 수 없음
  - 해당 방법을 통해도 MySQL 서버가 시작되지 않으면 백업을 이용하여 MySQL 서버 재구축
    - 백업이 있어야 새로 데이터베이스 구축, 바이너리 로그를 사용해 최대한 장애 시점까지의 데이터를 복구 가능

> 바이너리 로그를 이욯하여 데이터를 장애 시점까지 복구가 가능하다는데 구체적인 방법이 무엇일까?

### `InnoDB 버퍼 풀`

- InnoDB 스토리지 엔진에서 가장 핵심적인 부분
- 디스크의 데이터 파일이나 인덱스 정보를 메모리에 캐시해 두는 공간
- 쓰기 작업을 지연시켜 일괄 작업으로 처리할 수 있게 해주는 버퍼 역할도 포함
  - CUD 성격의 쿼리는 데이터 파일의 이곳저곳에 있는 랜덤한 디스크 작업을 발생시킴
  - 버퍼 풀이 이러한 변경된 데이터를 모아서 처리하면 랜덤한 디스크 횟수를 줄일 수 있음

> "버퍼 풀이 이러한 변경된 데이터를 모아서 처리하면 랜덤한 디스크 횟수를 줄일 수 있음" 방법이 무엇일지 생각해보자

#### 버퍼 풀 크기 설정

- InnoDB 버퍼 풀의 크기를 적절히 작은 값으로 설정 후에 조금씩 상황에 따라 증가시키는 방법이 최적
- innodb_buffer_pool_size 시스템 변수로 InnoDB 버퍼 풀 사이즈를 설정 가능, 동적으로 버퍼 풀의 크기를 확장 가능
  - 버퍼 풀의 크기는 크리티컬한 변경이므로 서버가 한가한 시점을 골라 진행하는 것을 권장
  - 버퍼 풀의 크기를 크게 하는 것은 영향도가 적지만 작게 하는 것은 영향도가 매우 큼
    - 가능하면 버퍼 풀의 크기를 줄이는 작업은 하지 않는 것을 권장
  - 내부적으로 128MB의 청크 단위로 관리, 버퍼 풀의 크기를 줄이거나 늘리기 위한 단위 크기
  - 버퍼 풀의 크기를 늘릴려면 관련된 MySQL 메뉴얼을 먼저 숙지
- InnoDB 버퍼 풀은 전통적으로 버퍼 풀 전체를 관리하는 잠금(세마포어)으로 인해 경합을 많이 유발
- innodb_buffer_pool_instance 시스템 변수를 통해 버퍼 풀을 여러개로 분리해서 관리 가능
  - 잠금에 대한 경합을 분산할 수 있음, 기본적으로 8개
  - 전체 버퍼 풀을 위한 메모리 크그기가 1GB 미만이면 버퍼풀 인스턴스는 1개만 생성 

#### 버퍼 풀의 구조

- InnoDB 스토리지 엔진은 버퍼 풀이라는 거대한 메로리 공간을 페이지 크기(innodb_page_size)의 조각으로 쪼개어 관리 
- InnoDB 스토리 엔진은 크게 LRU(Least Recently Used) 리스트, 플러시(Flush) 리스트 프리(Free) 리스트라는 3개의 구조로 관리
  - 프리(Free) 리스트 : 실제 사용자 데이터로채워지지 않은 비어 있는 페이지 목록
  - LRU 리스트 : 엄밀히 LRU(Old), MRU(New) 리스트의 결합된 형태
    - 목적은 최대한 오랫동안 InnoDB 버퍼풀의 메모리에 유지해서 디스크 읽기를 최소화
    - 데이터를 찾는 과정
      - 필요한 레코드가 저장된 데이터 페이지가 버퍼 풀에 있는지 검사
        - InnoDB 어댑티브 해시 인덱스를 이용해서 페이지 검색(활성화 경우)
        - 해당 테이블의 인덱스(B-Tree)를 이용해 버퍼 풀에서 페이지 검색(어댑티브 해시 인덱스에서 못찾은 경우)
        - 버퍼 풀에 데이터 페이지가 있으면 해당 페이지를 MRU로 승급
      - 디스크에서 필요한 데이터 페이지를 버퍼 풀에 적재, 적재된 페이지 포인터를 LRU 헤더에 추가
      - 버퍼 풀의 LRU 헤더 부분에 적재된 데이터 페이지가 읽히면 MRU로 이동
      - 필요한 데이터가 자주 접근됐다면 해당 페이지의 인덱스 키를 어댑티브 해시 인덱스에 추가 
  - 플러시(Flush) 리스트 : 디스크로 동기화되지 않은 데이터를 가진 데이터 페이지(더티 페이지), 변경 시점 기준의 페이지 목록을 관리
    - 일단 한 번 데이터 변경되면 플러시 리스트에 관리, 특정 시점이 되면 디스크로 기록
- InnoDB는 변경 내용을 Redo log에 기록, 버퍼 풀의 데이터 페이지에도 변경을 반영
  - Redo log의 각 엔트리는 특정 데이터 페이지와 연결, 디스크로 기록됐다는 것을 항상 보장하지 않음

#### 버퍼 풀과 Redo log

- 데이터베이스 서버의 성능 향상을 위해 데이터 캐시와 쓰기 버퍼링 기능이 존재
- InnoDB의 버퍼 풀은 크게 설정하면 할수록 쿼리 성능이 빨라짐, 그러나 단순히 늘리는 것은 캐시 성능만 향상
- InnoDB의 버퍼 풀은 클린 페이지와 더티 페이지도 있음
  - 클린 페이지 : 디스크에서 읽은 상태로 전형 변경되지 않은 페이지
  - 더티 페이지 : INSERT, UPDATE, DELETE 명령으로 변경된 데이터 페이지
    - 디스크와 메모리(버퍼 풀)의 데이터 상태가 다르기 때문에 언젠가는 디스크로 기록
- Redo log는 1개 이상의 고정 크기 파일을 연결해서 순환 고리처럼 사용
  - 로그 파일에 있는 엔트리는 어느 순간 새로운 로그 엔트리로 덮음, 이때 로그 포지션 값(Log Sequence Number)은 계속 증가
    - InnoDB 엔진은 주기적으로 체크 포인트를 발생시켜 Redo log와 더티 페이지를 도시크로 동기화
      - 체크 포인트 LSN과 Redo log 엔트리의 마지막 LSN의 차이를 체크 포인트 에이지라고 함, Redo log 공간의 크기를 뜻함
    - 체크 포인트가 발생하면 LSN보다 작은 Redo log와 관련된 더티 페이지, Redo log 엔트리를 디스크 동기화
- 버퍼 풀의 더티 페이지 비율이 너무 높은 상태에서 버퍼 풀이 필요한 상황이 발생하면 많은 더티 페이지를 한번에 기록해야 하는 상황이 발생할 수 있음
 
> 일반적으로 Redo log는 변경분만 가지고 버퍼 풀은 데이터 페이지를 통째로 가지기 때문에 데이터 변경이 발생해도 Redo log는 훨씬 작은 공간만 필요

#### 버퍼 풀 플러시

- InnoDB 스토리지 엔진은 더티 페이지를 디스크에 동기화할 때 성능상 악영향 없이 하도록 2개의 플러시 기능을 백그라운드로 실행

##### 플러시 리스트 플러시

- Redo log 공간의 재활용을 위해 공간을 비워야 함
- Redo log 공간이 지워지려면 반드시 InnoDB 버퍼 풀의 더티 페이지가 먼저 디스크로 동기화
  - 이를 위해 주기적으로 플러시 리스트를 동기화하기 위한 플러시 함수를 호출
  - 언제부터 얼마나 많은 더티 페이지를 한번에 디스크로 기록하느냐에 따라 사용자의 쿼리 처리에 영향

> 플러시 리스트 플러시와 관련된 서버 설정 및 이해는 해당 단원을 상세 참고

##### LRU 리스트 플러시

- LRU 리스트에서 사용 빈도가 낮은 데이터 페이지들을 제거해서 새로운 페이지를 읽어올 공간을 마련
  - 이를 위해 LRU 플러시 함수 사용
    - innodb_lru_scan_depth 시스템 변수에 설정된 개수만큼 페이지를 스캔
      - 더티 페이지는 디스크에 동기화, 클린 페이지는 즉시 프리 르스트로 이전
      - innodb_lru_scan_depth * innodb_buffer_pool_instances 수만큼 LRU 리스트 스캔

#### 버퍼 풀 상태 백업 및 복구

- 워밍 업 : 디스크의 데이터가 버퍼 풀에 적재돼 있는 상태
- v5.6 부터 버퍼 풀 덤프 및 적재 기능 도입, inndb_buffer_pool_dump_now 시스템 변수를 이용하여 버퍼 풀의 상태를 백업 가능
- inndb_buffer_pool_load_now 시스템 변수를 이욯하여 백업된 버퍼풀의 상태를 다시 복구 가능
  - ib_buffer_pool이라는 이름으로 파일 생성, 크다 하더라도 몇십 MB 이하
    - 버퍼 풀의 LRU 리스트에 적재된 데이터 페이지의 메타 정보만 저장
    - 버퍼 풀의 백업은 빨리 완료 가능
  - 백업된 버퍼 풀의 내용을 다시 복구하는 과정은 InnoDB 버퍼 풀의 크기에 따라 상당한 시간이 소요될 수 있음
    - innodb_buffer_pool_load_abort 옵션으로 버퍼 풀 복구를 멈출 수 있음, 급히 서비스를 시작해야 하는 경우에 유용
  - ib_buffer_pool 파일에 실제 존재하지 않는 데이터 정보가 명시돼 있어도 서버가 비정상적으로 종료되지 않음
    - 꼭 셧다운 직전의 파일일 필요는 없음
- innodb_buffer_pool_dump_at_shutdown, innodb_buffer_pool_dump_at_startup 설정을 설정 파일에 넣어 버퍼풀 백업과 복구 과정을 잊어버리는 실수를 대비할 수 있음

#### 버퍼 풀의 적재 내용 확인

- v8.0 버전부터 information_schema 데이터베이스에 innodb_cached_indexs 테이블을 통해 인덱스별로 데이터 페이지가 얼마나 버퍼 풀에 적재돼 있는지 확인 가능

> 상세 쿼리는 해당 단원을 확인

### `Double Write Buffer`

- 더티 페이지를 디스크 파일로 플러시할 때 일부만 기록되는 문제가 발생할 수 있음
  - 이로 인해 해당 페이지의 내용은 복구할 수 없을 수도 있음
  - 페이지 일부만 기록되는 현상을 파셜(partial) 페이지, 톤(torn) 페이지라고 함
  - 하드웨어 오작동이나 시스템 비정상 종료 등으로 발생할 수 있음

> Double Wirte 작동 방식에 대한 그림 확인

- InnoDB 스토리지 엔진은 데이터 파일 변경을 기록하기 전에 더티 페이지를 묶어 한 번의 디스크 쓰기로 시스템 테이블스페이스의 DoubleWirte 버퍼에 기록
- 더티 페이지가 정상적으로 기록되면 DoubleWirte는 필요가 없어짐
- 비정상적인 종료 후에 InnoDB 스토리지 엔진이 재시작될 때 DoubleWirte 버퍼 내용과 데이터 파일의 페이지를 비교하여 다른 내용이면 DoubleWirte 내용을 파일의 페이지로 복사
- innodb_doublewrite 시스템 변수로 사용 제어
  - 데이터의 무결성이 매우 중요한 서비스는 해당 변수를 활성화 하는 것을 권장
  - innodb_flush_log_at_trx_commit 를 1이 아닌 값으로 설정했다면 비활성화 하는 것이 좋음

> innodb_flush_log_at_trx_commit 를 1이 아닌 값으로 설정했다면 왜 innodb_doublewrite를 비활성화 하는 것이 좋을까?

### `Undo log`

- InnoDB 스토리지 엔진은 트랜잭션과 격리 수준을 보장하기 위해 DML에 대한 Undo log를 저장
- 매우 중요한 역할이며 관리 비용도 많이 필요

#### Undo log 레코드 모니터링

- Undo log는 트랜잭션 보장, 격리 수준 보장에 사용
- 데이터 변경이 일어나면 Undo log에 이전 값을 백업, 커밋되면 그대로 유지하고 롤백되면 Undo log를 사용하여 복구
- 높은 동시성 제공을 위해 사용, 이는 트랜잭션의 격리 수준과 연관되어 있음
- Undo log는 데이터 변경에 대한 레코드가 트랜잭션에 걸려 있으면 쉽게 삭제할 수 없음
  - 많이 누적된 Undo log는 디스크 사용량이 증가하며 레코드 조회에 대해 Undo log의 이력을 필요한 만큼 스캔해야하기 때문에 성능이 전반적으로 저하
- v5.5 까지는 Undo log 사용 공간이 한번 늘어나면 서버를 새로 구축하지 않는 한 줄일 수 없었음
- v5.7, v8.0 이상은 Undo log 공간의 문제점은 완전히 해결

> 어떤 방법으로 Undo log 공간의 문제점을 해결했을까?

> Mysql 서버의 언두 로그 레코드 건수를 확인할 수 있음. 책을 참고

#### Undo log 테이블스페이스 분리

- v5.6 이전에는 시스템 테이블스페이스(ibdata.ibd)에 저장
- v8.0 부터는 Undo log는 항상 시스템 테이블페이스 외부의 별도 로그 파일에 기록되도록 개선
- Undo log 테이블 스페이스에 대한 상세 내용
  - 하나의 Undo log 테이블스페이스는 1개 ~ 128개 롤백 세그먼트를 갖을 수 있고 롤백 세그먼트는 1개 이상의 Undo 슬록을 갖음
  - 하나의 롤백 세그먼트는 InnoDB의 페이지 크기를 16바이트로 나눈 값의 개수만큼  Undo 슬록 갖음
  - 하나의 트랜잭션이 필요로 하는 Undo 슬록의 개수는 트랜잭션이 실행되는 INSERT, UPDATE, DELETE 문장 특성에 따라 최대 4개까지 슬롯을 사용
- 최대 동시 트랜잭션 수 = InnoDB 페이지 크기 / 16 * 롤백 세그먼트 개수 * 언두 테이블스페이스 개수
- Undo log 공간이 남는 것은 문제되지 않지만 부족한 경우에는 트랜잭션을 시작할 수 없기 때문에 심각한 문제

> 추가적인 상세 내용은 해당 단원을 확인

### `체인지 버퍼`

- 레코드 변경에 대해 파일을 변경하는 작업뿐 아니라 해당 테이블에 포함된 인덱스를 업데이트하는 작업도 필요
- 인덱스를 업데이트하는 작업은 랜덤하게 디스크를 읽는 작업이 필요하므로 인덱스가 많다면 상당한 많은 자원을 소모
- InnoDB는 변경해야 할 인덱스 페이지가 버퍼 풀에 있으면 즉시 업데이트 수행
- InnoDB는 변경해야 할 인덱스 페이지가 버퍼 풀에 없으면 디스크로부터 읽어와서 임시 공간에 저장해 두고 바로 사용자에게 결과를 반환
  - 임시 공간을 통해 성능 향상이 목적
  - 이러한 임시 공간을 체인지 버퍼라고 함
  - 이후 백그라운드 스레드에 의해 병합 (체인지 버퍼 머지 스레드)
- v5.5 부터 innodb_change_buffering 시스템 변수를 통해 체인지 버퍼 사용 범위를 설정 가능
  - v5.5 이전에는 INSERT 작업만 가능
- 사용자에게 결과를 전달하기 전에 반드시 중복 여부를 체크해야 하는 유니크 인덱스는 체인 버퍼를 사용할 수 없음
- 기본적으로 InnoDB 버퍼풀로 설정된 메모리 공간의 25%까지 사용 가능, 50% 까지도 사용가능하도록 설정 가능
  - innodb_change_buffer_max_size 시스템 변수에 비율을 설정

> 체인지 버퍼가 버퍼 풀의 메로리를 얼마나 사용중인지 확인하는 상세 쿼리는 해당 단원을 확인

### `Redo log 및 로그 버퍼`

- ACID 중에서 D에 해당하는 영속성과 가장 밀접하게 연관
- 모든 DBMS에서 데이터 파일은 쓰기보다 읽기 성능을 고려한 자료 구조이기 때문에 파일 쓰기는 디스크의 랜덤 엑세스가 필요
- 변경된 데이터를 파일에 기록하려면 상대적으로 큰 비용 필요
- Redo log를 이용하여 비정상 종료에 대한 복구 작업을 수행
- ACID도 중요하지만 성능도 중요하기 때문에 Redo log를 버퍼링 할 수 있도록 InnoDB 버퍼 풀이나 로그 버퍼를 갖고 있음
- 데이터베이스 서버에서 Redo log는 트랜잭션이 커밋되면 즉시 디스크로 기록되도록 시스템 변수를 설정하는 것을 권장
  - innodb_flush_log_at_trx_commit 시스템 변수로 설정 가능
    - DDL이 발생한 경우 Redo log가 디스크로 동기화되기 때문에 1초보다 간격이 작을 수 있음
    - 값이 0이나 2인 경우에는 1초 정도 Redo log의 손실이 발생할 수 있음
  - 커밋될 때마다 Redo log를 디스크에 기록하는 작업은 많은 부하를 유발
- innodb_log_file_size, innodb_log_files_in_group 시스템 변수를 통해 Redo log의 파일 크기, 파일의 개수를 결정
  - 전체 Redo log 파일의 크기는 두 시스템 변수의 곱
- Redo log 파일 전체 크기는 InnoDB 버퍼 풀 크기에 맞게 적절히 선택되어야 함

> Redo log 파일 전체 크기는 InnoDB 버퍼 풀 크기에 맞게 적절히 선택되어야 하는 이유가 무엇일까?

#### Redo log 아키이빙

> 관련하여 해당 단원을 한번 읽어보는 것으로 넘긴다.

#### Redo log 활설화 및 비활성화

- Redo log 비활성화 하여 데이터 적재 시간을 단축시킬 수 있음
- 적재 작업을 완료 후 Redo log를 다시 활성화 하는 것을 잊지 말아야 함
  - 만약 활성화 하지 못한 상태에서 비정상적으로 종료되면 마지막 체크 포인트 이후의 데이터는 복구할 수 없음
  - 10시 정각에 체크포인트 실행 후 10시 1분에 비정상적 종료가 발생 후 재시작하면 10시 ~ 10시 1분의 다양한 시점의 데이터를 골고루 갖을 수 있음
  

  

### `어댑티브 해시 인덱스`

- 사용자가 수동으로 생성한 B-Tree와 같은 인덱스가 아니라 InnoDB 스토리지 엔진에서 사용자가 자주 요청하는 데이터에 대해 자동으로 생성하는 인덱스
  - innodb_adaptive_hash_index 시스템 변수를 이용하여 활성화 여부 설정 가능
- B-Tree 인덱스
  - 루트 노드를 거쳐서 브렌치 노드, 최종적으로 리프 노드까지 찾아가야 원하는 레코드를 읽을 수 있음
  - 이런 작업이 동시에 몇천 개의 스레드로 실행되면 컴퓨터 CPU는 엄청난 프로세스 스케줄링을 하게 되고 자연히쿼리 성능을 덜어짐
    - 데이터베이스 서버가 얼마나 많은 일을 하느냐에 따라 인덱스에서 값을 찾는 과정이 느려질 수도 빨라질 수도 있음
- 어댑티브 해시 인덱스는 이러한 B-Tree 검색 시간을 줄여주기 위해 도입
  - InnoDB 스토리지 엔진은 자주 읽히는 데이터페이지의 키 값을 이용해 해시 인덱스를 생성
  - 필요할 대마다 어댑티브 해시 인덱스를 검색하여 레코드가 저장된 데이터 페이지를 즉시 찾음
  - B-Tree의 루트부터 리프까지 찾아가는 비용이 없어지고 CPU는 적은 일을하며 쿼리 성능이 빨라짐, 동시 처리할 수 있는 쿼리 증가
- 해시 인덱스는 '인덱스 키 값', 해당 인덱스 키 값이 저장된 '데이터 페이지 주소'의 쌍으로 관리
  - 인덱스 키는 'B-Tree' 인덱스의 고유번호(id)와 'B-Tree 인덱스 실제 키 값'으로 조합
  - 인덱스의 고유번호(id)를 키로 갖는 이유는 InnoDB 스토리지 엔진에서 어댑티브 해시 인덱스는 하나만 존재하기 때문임
  - '데이터 페이지 주소'는 실제 키 값이 저장된 데이터페이지의 메모리 주소이며 버퍼 풀에 로딩된 페이지 주소를 의미
    - 즉, 어댑티브 해시 인덱스는 버퍼 풀에 올려진 데이터페이지에 대해서만 관리, 버퍼 풀에서 페이지가 사라지면 어댑티브 해시 인덱스에서도 사라짐

> 성능에 대한 비교를 위해 해당 단원을 참고

- v8.0 부터는 어댑티브 해시 인덱스의 파티션 기능을 제공
  - innodb_adaptive_hash_index_parts 시스템 변수로 설정, 기본 값은 8개
  - 파티션이 되어 어댑티브 인덱스의 경합을 줄일 수 있음. 즉, 내부 잠금 경합을 줄일 수 있음
- 어댑티브 해시 인덱스는 버퍼 풀에 있는 페이지에 접근하는 것을 더 빠르게 만드는 기능
  - 도움이 별로 되지 않는 경우
    - 디스크 읽기가 많이 발생하는 경우
    - 특정 패턴 쿼리가 많은 경우, 조인이나 LIKE
    - 매우 큰 데이터를 가진테이블의 레코드를 폭넓게 읽는 경우
  - 도움이 되는 경우
    - 디스크 읽기가 별로 없는 경우
    - 동등 조건 검색이 많은 경우, 동등 비교나 IN
    - 쿼리가 데이터 중에서 일부 데이터만 집중되는 경우
- 어댑티브 해시 인덱스를 사용했을 때 단점
  - 저장 공간인 메모리를 사용해야 하며 때로는 이 메모리가 클 수 있음
  - 해시 인덱스가 있든 없든 일단 검색해봐야 알 수 있음
  - 테이블이 DROP, ALERT 할 경우 해당 테이블이 가진 모든 데이터의 내용을 어댑티브 해시 인덱스에서 제거해야 함, CPU 많이 소모
- Mysql의 어댑티브 해시 인덱스는 기본적으로 활성화 되어 있고 불필요한지 확인이 필요할 수 있음

> 어댑티브 해시 인덱스에 대한 필요성 상세 검증은 해당 단원을 참고

## MyISAM 스토리지 엔진 아키텍처

> 중요도 판단에 따른 해당 내용은 서적을 참고

## MySQL 로그 파일

### `에러 로그 파일`

- my.cnf log_error 라는 이름의 파라미터로 정의된 경로
- .err 확장자가 붙는 파일로 생성

#### MySQL이 시작하는 과정과 관련된 정보성 및 에러 메세지

- 비정상적으로 종료된 이후 다시 시작하는 경우 MySQL 에러 로그 파일을 통해 설정된 변수 이름, 값 확인
- 변수명을 인식하지 못하거나 설정된 파라미터 값 내용을 인식 못한 경우에는 에러 메세지 출력

#### 마지막으로 종료할 때 비정상적으로 종료된 경우 InnoDB 트랜잭션 복구 메시지

- 복구 과정에서 간단한 메세지 출력
- 복구를 실패하는 경우 에러 메세지 출력 후 서버 종료
- innodb_forece_recovery 파라미터를 활용해야 할 수 있음

#### 쿼리 처리 도중에 발생하는 문제에 대한 에러 메세지

- 주기적으로 에러 로그 파일 검토하는 과정에서 알 수 있음
- 쿼리 실행 도중에 발생한 에러 로그나 복제에서 문제가 될 만한 쿼리에 대한 경고 로그 기록
- 데이터베이스에 숨겨진 문제점을 해결하는데 도움

#### 비정상적으로 종료된 커넥션 메시지

- 클라이언트 애플리케이션이 정상적으로 접속 종료르 하지 못하고 프로그램이 종료되는 경우 로그 기록
- 네트워크에 의한 접속이 끊기는 경우도 메세지 기록
- 너무 많이 기록된다면 커넥션 종료 로직을 검토해볼 필요가 있음

#### InnoDB 모니터링 또는 상태 조회명령의 결과 메시지

- 로그 내용이 큰 메세지가 많음
- InnoDB 모니터링 활성화 이후에 비활성화해서 로그 파일이 커지지 않도록 해야함

#### MySQL의 종료 메시지

- MySQL이 아무도 모르게 재시작되는 경우가 있음
- 이러한 경우 로그 파일에서 MySQL이 마지막 종료되면서 출력한 메세지를 확인

### `제너럴 쿼리 로그 파일`

- 서버에서 실행되는 쿼리로 어떤 것들이 있는지 검토할 때, 쿼리 로그를 활성화 해서 로그 파일을 검토
- 실행 단위로 실행됐던 쿼리의 내용이 모두 기록

### `슬로우 쿼리 로그`

- long_query_time 시스템 변수에 설정한 이상 소요된 쿼리를 기록
- 쿼리가 정상적으로 실행이 완료돼야 쿼리 로그에 기록
- log_output 을 통해 슬로우 쿼리 로그를 파일 or 테이블로 기록할지 선택
  - TABLE로 설정하면 제너럴 로그, 슬로우 쿼리 로그를 mysql DB의 general_log, slow_log 테이블에 저장
  - FILE로 설정하면 디스크 파일로 저장

> 슬로으 쿼리 로그에 대한 분석은 공식 문서를 참고

#### 슬로우 쿼리 통계

> 관련한 상세 내용은 해당 단원을 참고