## 4. 아키텍처

### 4.1 MySQL 엔진 아키텍처
- MySQL의 전체 구조
    - MySQL 서버
        - MySQL 엔진
            > 커넥션 핸들러와 SQL 파서 및 전처리기, 쿼리의 최적화된 실행을 위한 옵티마이저가 중심을 이룬다.
            - **커넥션 핸들러**
            - **SQL 인터페이스**
            - **SQL 파서**
            - **SQL 옵티마이저**
            - **캐시 & 버퍼**
        - 스토리지 엔진
            > 실행 데이터를 디스크 스토리지에 저장하거나 디스크 스토리지로부터 데이터를 읽어오는 부분을 전담.
            - **InnoDB**
            - **MyISAM**
            - **Memory**

- MySQL 스레딩 구조
    - 포그라운드 스레드
        > 데이터 버퍼나 캐시로부터 데이터를 가져오며, 없는경우 직접 디스크의 데이터나 인덱스 파일로부터 데이터를 읽어와서 작업을 처리
    - 백그라운드 스레드
        > 여러 중요한 역할을 수행하고 이것들은 모두 중요 하지만 그 중 로그 스레드, 쓰기 쓰레드가 제일 중요
        - 인서트 버퍼를 병합하는 스레드
        - **로그를 디스크로 기록하는 스레드**
        - **InnoDB 버퍼 풀의 데이터를 디스크에 기록하는 스레드**
        - 데이터를 버퍼로 읽어 오는 스레드
        - 잠금이나 데드락을 모니터링하는 스레드

- 컴포넌트 vs 플러그인
    - 플러그인의 여러가지 단점
        - 오직 MySQL 서버와 인터페이스할 수 있고, 플러그인끼리는 통신할 수 없음
        - MySQL 서버의 변수나 함수를 직접 호출하기 때문에 안전하지 않음(캡슐화 안 됨)
        - 상호 의존 관계를 설정할 수 없어서 초기화가 어려움

- 쿼리 실행 구조
    - **쿼리 파서**
    - **전처리기**
    - **옵티마이저**
    - **쿼리 실행기**        **
    ![image](https://user-images.githubusercontent.com/53131108/212582786-ff4de68f-02c9-4567-8ffb-7694df37fd61.png)

### 4.2 InnoDB 스토리지 엔진 아키텍처
- **프라이머리 키(PK, Primary Key)에 의한 클러스터링**
    - InnoDB의 모든 테이블은 기본적으로 PK를 기준으로 클러스터링되어 저장된다. (PK값의 순서대로 디스크에 저장)
    - 모든 세컨더리 인덱스는 레코드의 주소 대신 PK의 값을 논리적인 주소로 사용한다.
    - 쿼리 실행 계획에서 PK는 기본적으로 다른 보조 인덱스에 비해 비중이 높게 설정된다.

---

- **외래 키(FK, Foreign Key) 지원**
    - InnoDB에서 FK는 부모 테이블과 자식 테이블 모두 해당 컬럼에 인덱스 생성이 필요하고, 변경 시 반드시 부모 테이블이나 자식 테이블에 데이터가 있는지 체크하는 작업이 필요하므로 잠금이 여러 테이블로 전파되고, 그로 인해 데드락이 발생할 때가 많으므로 개발할 때도 FK의 존재에 주의하는 것이 좋다.

---

- **MVCC(Multi Version Concurency Control)**
    - 잠금을 사용하지 않는 일관된 읽기를 제공하는 데 있다.
    - READ_COMMITTED 이상의 격리수준에서는 언두영역의 데이터를 읽어서 반환
    
---

- **잠금 없는 일관된 읽기(Non-Locking Consistent Read)**
    - SERIALIZABLE 격리수준 이외의 격리수준에선 INSERT와 연결되지 않은 순수한 읽기(SELECT) 작업은 다른 트랜잭션의 변경 작업과 관계없이 항상 잠금을 대기하지 않고 바로 실행된다.

---

- **자동 데드락 감지**
    - 데드락에 걸린 트랜잭션들을 찾아 강제 종료
    - 어느것을 먼저 강제 종료 할지의 기준은 트랜잭션의 언두 로그 양이다.
    - 언두 로그 양이 적을수록 롤백을 해도 언두 처리를 해야 할 내용이 적다는 것을 의미 함.
    - 이를 통해 MySQL 서버의 부하도 덜 유발

---

- **자동화된 장애 복구**
    - **MySQL 서버**가 시작될 때 **완료되지 못한 트랜잭션**이나 **디스크에 일부만 기록된(Partial write) 데이터 페이지** 등에 대한 일련의 복구 작업이 자동으로 진행된다.

---

- **InnoDB 버퍼 풀**
    - 디스크의 데이터 파일이나 인덱스 정보를 메모리에 캐시해 두는 공간
    - INSERT, UPDATE, DELETE처럼 데이터를 변경하는 쿼리는 데이터 파일의 이곳저곳에 위치한 레코드를 변경하기 때문에 랜덤한 디스크 작업을 발생시킨다.
    - InnoDB 버퍼 풀은 이러한 변경 데이터를 모아서 처리하여 **랜덤 디스크 엑세스(Random Disk Access) 횟수**를 줄일 수 있다.

---

- **버퍼 풀의 크기 설정**
    - 단순하게 설정해서 되는 값이 아님.
    - InnoDB 버퍼풀의 레코드 **버퍼 공간**은 **전체 커넥션 개수**와 **각 커넥션에서 읽고 쓰는 테이블의 개수**에 따라서 결정된다.

---

- **버퍼 풀의 구조**
    - **InnoDB 스토리지 엔진**은 **버퍼 풀**이라는 **거대한 메모리 공간**을 **페이지 크기(innodb_page_size 시스템 변수에 설정된)** 의 조각으로 쪼개어 **InnoDB 스토리지 엔진이 데이터를 필요로 할 때 해당 데이터 페이지를 읽어서 각 조각에 저장**
    - **버퍼 풀의 페이지 크기 조각**을 관리하기 위해 **InnoDB 스토리지 엔진**은 크게 **3개의 자료구조를 관리**한다.
    - **LRU(Least Recently Used) 리스트** -> LRU, MRU(Most Recently Used) 함께 결합된 형태
    - **Flush 리스트**
    - **Free 리스트**

    - **InnoDB 스토리지 엔진에서 데이터를 찾는 과정**
        1. 필요한 레코드가 저장된 **데이터 페이지**가 **버퍼 풀**에 있는지 **검사**
        2. 디스크에서 필요한 **데이터 페이지**를 **버퍼 풀에 적재**하고, **적재된 페이지**에 대한 **포인터**를 **LRU 헤더 부분에 추가**
        3. 버퍼 풀의 LRU 헤더 부분에 **적재된 데이터 페이지**가 **실제로 읽히면 MRU 헤더 부분으로 이동**
        4. 버퍼 풀에 상주하는 데이터 페이지는 사용자 쿼리가 얼마나 최근에 접근했었는지에 따라 **나이(Age)** 가 부여되며, 
        오랫동안 사용되지 않으면 **나이가 오래되고(Aging)** 결국 해당 데이터 페이지는 버퍼 풀에서 제거된다.
        버퍼 풀의 **데이터 페이지**가 **쿼리에 의해 사용**되면 **나이가 초기화**되어 다시 **젊어지고** **MRU의 헤더 부분으로 옮겨진다.**
        5. 필요한 데이터가 자주 접근됐다면 해당 페이지의 인덱스 키를 **어댑티브 해시 인덱스(Adaptive Hash Index)** 에 추가
---

- **버퍼 풀과 리두 로그**
    - DB 서버의 성능 향상을 위해 InnoDB 버퍼 풀의 두 가지 주요 기능
        - **데이터 캐시**
        - **쓰기 버퍼링**
    - InnoDB 버퍼 풀은 데이터 페이지를 읽어오는데 이때 전혀 변경되지 않은 클린 페이지(Clean Page), 더티 페이지(Dirty Page)를 가지고 있다.
        - 클린 페이지
            - 변경되지 않은 데이터를 가지는 페이지
        - 더티 페이지
            - INSERT, UPDATE, DELETE 명령으로 변경된 데이터를 가지는 페이지

---

- **버퍼 풀 플러시**
    - **MySQL 5.6 버전**까지는 InnoDB 스토리지 **더티 페이지 플러시 기능**이 **디스크 쓰기 폭증 현상**이 있었음.
    - **MySQL 8.0 버전**으로 업그레이드 되면서 대부분 디스크 쓰기 폭증 현상은 발생하지 않음.

---

- **플러시 리스트 플러시**

---

- **LRU 리스트 플러시**

---

- **버퍼 풀 상태 백업 및 복구**

---

- **버퍼 풀의 적재 내용 확인**

---

- **Double Write Buffer**

---

- **언두 로그**
    - **InnoDB 스토리지 엔진**은 **트랜잭션**과 **격리 수준**을 **보장**하기 위해 **DML(INSERT, UPDATE, DELETE)** 로 **변경되기 이전 버전**의 **데이터**를 별도로 **백업**한다.
    - **매우 중요한 역할을 담당, 관리 비용도 많이 필요**

---

- **언두 로그 모니터링**
    - 언두 로그의 데이터 활용
        - **트랜잭션의 롤백 대비용**
        - **트랜잭션의 격리 수준을 유지하면서 높은 동시성 제공**

---

- **언두 테이블스페이스 관리**
    - **언두 테이블 스페이스**: 1~128개의 **롤백 세그먼트**로 구성
    - **롤백 세그먼트**: 1개 이상의 **언두 슬롯(Undo Slot)** 으로 구성
    - **MySQL 8.0 버전**부터는 **언두 테이블 스페이스**를 **동적**으로 추가하고 삭제할 수 있게 개선됌.

---

- **체인지 버퍼**
    - RDBMS에서 레코드가 INSERT, UPDATE 될 때는 **데이터 파일을 변경하는 작업** + **해당 테이블에 포함된 인덱스를 업데이트하는 작업**도 필요
    - **인덱스를 업데이트하는 작업**은 **랜덤하게 디스크를 읽는 작업**이 필요 -> 성능에 영향
    - 성능 개선을 위해 이러한 작업은 **임시 공간에 저장** -> **체인지 버퍼**

---

- **리두 로그 및 로그 버퍼**
    - **ACID**중 **D(Durable)** 에 해당하는 **영속성**과 가장 밀접하게 연관
    - **데이터 파일 버퍼링** -> **InnoDB 버퍼 풀**
    - **리두 로그 버퍼링** -> **로그 버퍼**

    - MySQL 서버 **비정상 종료** 시 **InnoDB 스토리지 엔진의 데이터 파일**은 **일관되지 않은 데이터**를 가질 수 있음
        - 커밋됐지만 데이터 파일에 기록되지 않은 데이터
        - 롤백됐지만 데이터 파일에 이미 기록된 데이터

---

- **리두 로그 아카이빙**

---

- **리두 로그 활성화 및 비활성화**

---

- **어댑티브 해시 인덱스**
    - **InnoDB 스토리지 엔진**에서 사용자가 **자주 요청**하는 데이터에 대해 **자동으로 생성하는 인덱스**
    - **B-Tree 검색 시간을 줄여주기 위해 도입된 기능**
    - B-Tree 검색 시 -> 루트 노드 -> 브랜치 노드 -> 리프 노드 까지 찾아가야하는데 이 과정의 비용이 없어짐
    - 이것만 보면 어댑티브 해시 인덱스는 팔방미인으로 보이지만 실제 성능상 이점이 없는 경우도 많다.
    - 성능 향상에 크게 **도움이 되지 않는 경우**
        - 디스크 읽기가 많은 경우
        - 특정 패턴의 쿼리가 많은 경우(JOIN, LIKE 패턴 검색)
        - 매우 큰 데이터를 가진 테이블의 레코드를 폭 넓게 읽는 경우
    - 성능 향상에 **도움이 많이 되는 경우**
        - 디스크의 데이터가 InnoDB 버퍼 풀 크기와 비슷한 경우(디스크 읽기가 많지 않은 경우)
        - 동등 조건 검색(동등 비교와 IN 연산자)이 많은 경우
        - 쿼리가 데이터 중에서 일부 데이터에만 집중되는 경우

---

- **InnoDB, MyISAM, MEMORY 스토리지 엔진 비교**

---

### 4.3 MyISAM 스토리지 엔진 아키텍처
- MySQL 8.0에서 삭제

---

### 4.4 MySQL 로그 파일
- 에러 로그 파일
    - MySQL이 시작하는 과정과 관련된 정보성 및 에러 메세지
    - 마지막으로 종료할 때 비정상적으로 종료된 경우 나타나는 InnoDB의 트랜잭션 복구 메세지
    - 쿼리 처리 도중에 발생하는 문제에 대한 에러 메세지
    - 비정상적으로 종료된 커넥션 메세지
    - InnoDB의 모니터링 또는 상태 조회 명령의 결과 메세지
    - MySQL의 종료 메세지

---

- 제너럴 쿼리 로그
    - 슬로우 쿼리 로그
    - 슬로우 쿼리 통계
    - 실행 빈도 및 누적 실행 시간순 랭킹
    - 쿼리별 실행 횟수 및 누적 실행 시간 상세 정보