# 데이터 압축

- 데이터 파일의 크기는 쿼리 성능, 백업 및 복구 시간에 영향
  - 데이터 파일이 클수록 더 많은 데이터 페이지를 InnoDB 버퍼 풀로 읽어야 함
  - 페이지가 버퍼 풀로 적재되기 때문에 더티 페이지가 더 자주 디스크로 기록
  - 데이터 파일이 클수록 백업과 복구에 오래걸림

## 1. 페이지 압축

- 페이지 압축은 “Transparent Page Compression”이라고도 부름
- 디스크에 저장 하는 시점에 데이터 페이지가 압축 및 저장, 읽어올 때 압축이 해제
- 버퍼 풀에 데이터 페이지가 적재되면 압축이 해제된 상태로 관리
  - 압축 여부와 관계없이 "투명(Tranparent)"하게 작동
- 운영체제별로 특정 버전의 파일 시스템에서만 지원하는 펀치 홀이라는 기능을 사용

```
운영체제(파일 시스템)의 블록 사이즈를 512 바이트로 가정

1. 16KB 페이지를 압축, 7KB로 변화
2. MySQL 서버는 디스크에 7KB 기록, 9KB의 빈 데이터를 기록하여 16KB와 일치시킴
3. 9KB에 대해 펀치 홀(Punch-hole)을 생성
4. 파일 시스템은 7KB만 남기고 9KB 공간은 운영체제로 반납
```

- 펀치 홀 기능은 운영체제뿐만 아니라 하드웨어 자체에서도 해당 기능을 지원해야 함
- 시스템 관련 명령어가 펀치 홀을 지원하지 못함

> 펀치 홀 기능은 무엇을까?

> 파일 시스템은 운영 체제가 저장매체의  파일을 쓰기 위한 자료구조 혹은 알고리즘

> 파일 시스템에서 0과 1에 대한 저장을 비트 단위로 할 경우 오버헤드가 큼
>
> 블록마다 번호를 부여하여 관리, 저장 매체가 늘어나면 관리가 어려움, 결국 사용자는 파일을 관리 그러나 내부적으로 블록으로 관리

## 2. 테이블 압축

- 운영체제나 하드웨어에 대한 제약 없이 사용 가능, 활용도가 높은 편
- 디스크의 데이터 파일 크기를 줄일 수 있는 장점이 있으나 아래와 같은 단점도 존재
  - 버퍼 풀 공간 활용율이 낮음
  - 쿼리 처리 성능이낮음
  - 빈번한 데이터 변경 시 압축률이 떨어짐

### 2.1. 압축 테이블 생성

- 전제 조건으로 innodb_file_per_table 시스템 변수 값을 ON으로 설정
- 압축을 사용하는 테이블 생성시에 ROW_FORMAT=COMPRESSED, KEY_BLOCK_SIZE를 명시
  - KEY_BLOCK_SIZE만 명시된 경우 ROW_FORMAT은 생략 가능
  - KEY_BLOCK_SIZE는 2n 으로만 설정 가능, innodb_page_size가 16KB면 4KB 혹은 8KB 로 설정할 수 있음
- innodb_page_size가 32KB, 64KB인 경우 테이블 압축 적용이 불가

> innodb_file_per_table 시스템 변수의 기능과 해당 옵션을 ON 으로 해야하는 이유가 무엇일까?

> KEY_BLOCK_SIZE를 2n 으로만 설정 가능한 이유가 무엇일까?

- InnoDB 스토리지 인젠에 대한 압축 적용 방법 보기

```
innodb_page_size를 16KB, KEY_BLOCK_SIZE를 8(KB)로 설정했다고 가정

1. 16KB의 데이터 페이지를 압축
  1.1 압축된 결과가 8KB 이하이면 그대로 디스크에 저장(압축 완료)
  1.2 압축된 결과가 8KB를 초과하면 원본 페이지를 스플릿해서 2개의 페이지에 8KB씩 저장
2. 나뉜 페이지 각각에 대해 1번 단계를 반복 수행
```

- InnoDB 스토리지 엔진에서 수행하며 I/O와 관련된 InnoDB I/O 레이어와는 무관
- 중요한 것은 원본 데이터 페이지의 압축 결과가 목표 크기에 대해 이하일 때까지 반복해서 페이지를 스플릿

> p189 그림을 참고하면서 보자

> 참고 공식 문서
>> https://dev.mysql.com/doc/refman/8.0/en/innodb-compression-usage.html
>> https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_page_size

### 2.2. KEY_BLOCK_SIZE 결정

- 압축된 결과를 예측하여 KEY_BLOCK_SIZE를 결정
  - 4KB, 8KB로 샘플 데이터를 압축하여 저장하고 적절한지 판단하는 것이 좋음
  - 샘플 데이터는 많으면 많을수록 좋음
  
> 압축을 통한 실패율에 대한 예시를 해당 단원에서 확인 권고

- 압축 실패율이 높다고 해서 압축을 사용하지 말아야 한다는 것은 아님
- 데이터가 매우 빈번하게 조회되고 변경이 일어난다면 압축을 고려하지 않는 것이 좋음
- 테이블 압축은 zlib를 이용, CPU 소모가 생각보다 큼 

### 2.3. 압축된 페이지의 버퍼 풀 적재 및 사용

- InnoDB 스토리지 엔진은 압축된 테이블의 데이터 페이지를 압축된 상태, 압축이 해제된 상태로 2개를 버퍼 풀에 적재
  - 디스크에서 그대로 읽는 상태인 LRU, 압축된 페이지들의 압축 해제 버전인 Unzip_LRU
    - Unzip_LRU는 압축이 적용되지 않은 테이블의 데이터 페이지는 존재하지 않음
  - 버퍼 풀의 공간을 이중으로 사용하며 메모리 낭비하는 효과
- InnoDB 버퍼 풀의 공간이 필요한 경우 Unzip_LRU 리스트에서 해제된 버전은 제거하여 공간 확보
- 압축된 데이터 페이지가 자주 사용되는 경우 Unzip_LRU에 압축 해제된 페이지를 유지
- 압축된 페이지가 사용되지 않아서 LRU 리스트에서 제거되는 경우 Unzip_LRU에서도 제거
InnoDB 스토리지 엔진은 압축 해제된 버전의 데이터 페이지를 적절히 유지하기 위해 어댑티브 알고리즘 사용
  - CPU 사용량이 많은 경우 Unzip_LRU 비율을 높이고 압축과 압축 해제를 피함
  - Disk IO 사용량이 높은 서버는 Unzip_LRU 리스트 비율을 낮추고 InnoDB 버퍼 풀의 공간을 더 확보

> "Disk IO 사용량이 높은 서버는 Unzip_LRU 리스트 비율을 낮추고 InnoDB 버퍼 풀의 공간을 더 확보" 하는 이유는 무엇일까?

### 2.4. 테이블 압축 관련 설정

> 관련해서는 해당 단원을 참고