# 데이터 암호화


- v5.7부터 암호화 기능 제공, 처음에는 데이터 파일(테이블스페이스)에 댛서만 암호화 가능
- MySQL v8.0 부터는 데이터 파일뿐만 아니라 리두, 언두 로그, 복제를 위한 바이너리 로그도 암호화 지원


## 1. MySQL 서버의 데이터 암호화

- 데이터베이스 서버(InnoDB 스토레지 인젠 I/O 레이어)와 디스크 사이의 데이터를 읽고 쓰는 지점에서 암복호화를 수행
  - 디스크 입출력 이외의 부분에서 암복호화 처리는 불필요
- 사용자는 데이터 암호화를 식별할 필요 없이 쿼리 처리, 암호화 방식을 TDE(Transparent Data Encryption)이라  함

### 1.1. 2단계 키 관리

- MySQL 서버의 TDE는 키링(KeyRing) 플로그인에 의해 관리
- MySQL 커뮤니티 에디션은 keyring_file 플러그인만 사용 가능

> 해당 단원에서 MYSQL 엔터프라이즈 에디션이 사용 가능한 플러그인 참고

- MySQL 서버의 키링 플러그인은 2단계(2-Tier) 키 관리 방식을 사용
  - 데이터 암호화는 마스터 키, 테이블스페이스 키라는 두종류 키 존재
  - 테이블 스페이스 키는 프라이빗 키라고도 함
- 키 획득 시점
  - 외부 키 관리 솔루션 혹은 디스크의 파일에서 마스터 키를 획득
    - 마스터 키는 외부에 노출될 가능성이 존재
    - 주기적으로 변경하는 것을 권장
  - 암호화된 테이블이 생성될 때마다 해당 테이블을 위한 임의의 테이블스페이스 키 발급
- 마스터 키를 이용하여 테이블스페이스 키를 암호화해서 각 테이블의 데이터 파일 헤더에 저장
  - 테이블스페이스 키는 테이블이 삭제되ㅣ지 않는 한 절대 변경 불가
- 마스터 키가 변경될 경우 테이블스페이스 키를 복호화한 다음 새로운 마스터 키로 다시 암호화
- 2단계 암호화 방식을 사용하는 이유는 암호화 키 변경으로 인한 과도한 시스템 부하 방지를 위함
  - 테이블스페이스 키가 변경된다면 데이터 파일의 모든 데이터를 복화하 후 다시 암호화를 해야하는 일이 발생해야 함


### 1.2. 암호화와 성능

- MySQL 서버의 암호화는 TDE 방식이며 디스크로 한번 읽은 데이터 페이지는 복호화하여 InnoDB 버퍼 풀에 적재
  - 버퍼 풀에 한번 적재되면 암호화되지 않은 테이블과 동일한 성능을 보임
- InnoDB 버퍼 풀에 존재하지 않는 데이터 페이지를 읽거나 암호화된 테이블이 변경되면 암복호화 진행을 위한 추가적 시간을 소모
  - 사용자 쿼리에 대한 처리는 백그라운드 스레드가 수행하기 때문에 실제 사용자는 지연을 체감할 수 없을 수 있음
- TDE를 사용한다고 해도 테이블 파일의 크기가 동일, InnoDB 버퍼 풀의 효율이 달라지지 않음
- 테이블에 대해 암호화와 압축을 동시에 적용하면 압축을 먼저 실행하고 암호화를 적용
  - 일반적으로 암호화된 결과는 랜덤한 바이트 배열을 갖고 이는 압축률을 감소키기 때문에 압축을 먼저 적용
  - 암호화된 테이블은 InnoDB 버퍼 풀에 적재, 압축된 테이블은 압축 또는 압축 해제의 모든 상태로 InnoDB 버퍼 풀에 적재할 수 있음
    - 암호화 후 압축이 적용된다면 매번 암복호화 작업을 수행해야 함
  
> 암호화된 테이블과 암호화 하지 않은 테이블의 성능 비교는 해당 단원을 참고


### 1.3. 암호화와 복제

- TDE를 이용한 암호화 사용 시 마스터 키는 MySQL 각 노드 각자의 마시터 키를 할당해야 함
  - 마스터 키 자체가 레플리카로 복제되지 않음
  - 암호화 되기 전의 값은 동일하더라도 실제 암호화된 데이터 파일의 내용은 완전히 달라짐
- 마스터 키 변경 명령어 자체는 레플리카 서버로 복제되지만 마스터 키 자체가 전달되지는 않음
- MySQL 백엽에서 TDE의 키링도 함께 백업해야 함, 만약 키링 파일을 찾지 못하면 데이터 복구가 불가능

> 원격 키 솔루션을 사용하는 경우에 왜 소스 서버와 레플리카 서버는 서로 다른 마스터 키를 갖도록 설정해야 할까?

## 2. keyring_file 플러그인 설치

- MySQL 커뮤니티 에디션에서는 keyring_file 플러그인만 가능, 엔터프라이즈 에디션은 플러그인이 다양함
- keyring_file 플러그인은 마스터 키를 디스크의 파일로 관리, 해당 키는 평문으로 저장되어 있음
  - 해당 키가 노출된다면 데이터 암호화는 무용지물
- MySQL 서버 시작되는 단계에서 가장 빨리 초기화가 필요
  - my.cnf에 `early-plugin-load` 시스템 변수에 keyring_file 플러그인을 위한 라이버르리를 명시 필요
  - 마스터 키를 저장할 키링 파일의 경로를 `keyring_file_data` 설정에 명시
  - 서버 재시작 후에 `SHOW PLUGINS;` 를 통해 초기화 여부 확인 가능

> keyring_file_data 에 설정한 경로에 대해 마스터 키 초기화 관련 내용을 참고로 더 읽어보자.


## 3. 테이블 암호화

### 3.1. 테이블 생성

> 암호화 테이블 생성 예시 및 서버의 모든 테이블에 대해 암호화 적용에 대한 내용을 원한다면 해당 단원 참고

### 3.2. 응용 프로그램 암호화의 비교

- 응용 프로그램에서 직접 암호화해서 MySQL에 저장할 경우 이는 서버에서 인지하지 못함
- 응용 프로그램 암호화의 경우 완전 일치를 통해 조회
- MySQL 암호화를 사용할 경우 인덱스 관련된 작업을 모두 처리한 후 최종 디스크에 저장할 때만 암호화하기 때문에 제약 없음
- TDE의 경우 MySQL에 로그인만 할 수 있다면 모든 데이터를 평문으로 확인 가능, 응용 프로그램 암호화는 확인 불가

> 응용 프로그램에서의 암호화와 MySQL 서버의 암호화를 사용했을 때 장단점에는 무엇이 있을까?

### 3.3. 테이블스페이스 이동

- 테이블을 다른 서버로 복사해야 하거나 특정 테이블의 파일만 백업하는 경우 테이블스페이스 이동 기능이 레코드 복구 방식보다 효율적이고 빠름

> 해당 내용을 다시 한번 정독하자

## 4. 언두 로그 및 리두 로그 암호화

- `innodb_undo_log_encrypt`, `innodb_redo_log_encrypt` 시스템 변수를 이용해 암호화 가능
- 테이블 암호화의 경우 암호화가 적용되면 모든 데이터가 암호화
- 언두 로그 및 리두 로그 암호화는 암호화가 활성화되면 그때부터 생성되는 로그에 대해 암호화하여 저장
  - 비활성화도 마찬가지로 비활성화 시점부터 평문으로 저장, 과거 암호화된 내용은 그대로 유지
- 테이블스페이스 키로 암호화, 테이블스페이스는 다시 마스터 키로 암호화
  - 언두, 리두에 사용되는 암호화 키는 테이블의 테이블스페이스 키가 아닌 각각 새로 발급된 프라이빗 키, 해당 프라이빗 키를 마스터 키로 암호화
  - 암호화된 프라이빗 키는 리두 로그 파일과 언두 로그 파일의 헤더에 저장

## 5. 바이너리 로그 암호화

- 언두 로그와 리두 로그의 경우 길지 않은 시간 동안의 데이터만 가지기 때문에 보안에 상대적으로 덜 민감할 수 있음
- 바이너리로그는 의도적으로 긴 시간 동안 보관하는 서비스도 있고, 증분 백업을 위해 보관하기도 함
  - 상황에 따라 언두 로그나 리두 로그보다 암호화에 대한 중요도가 높을 수 있음
- 파이너리 로그와 릴레이 로그 파일 암호화는 파일에 대한 암호화, 메모리나 네트워크 구간에서 로그 데이터는 암호화하지 않음
- 네트워크 암호화를 원한다면 MySQL 복제를 위한 계정이 SSL을 사용하도록 설정
  - 3장의 `사용자 및 권한` 참조

### 5.1. 바이너리 로그 암호화 키 관리

- 파일 키(File key)로 암호화해서 디스크로 저장
- 파일 키는 바이너리 로그와 릴레이 로그 파일 단위로 자동으로 생성되어 해당 로그 파일의 데이터 암호화에만 사용

### 5.2. 바이너리 로그 암호화 키 변경

- 암호화 키 변경에 따른 과정
  - 증가된 시퀀스 번호와 새로운 바이너리 로그 암호화 키 발급 후 키링 파일에 저장
  - 바이너리 로그 파일과 릴레이 로그 파일 스위치(새로운 로그 파일로 로테이션)
  - 새로 생성된 바이너리 로그와 릴레이 로그 파일의 암호화를 위해해 파일 키를 생성, 파일 키는 바이너리 로그 파일키로 암호화해서 각 로그 파일에 저장
  - 기존 바이너리 로그와 릴레이 로그 파일의 파일 키를 읽어서 새로운 바이너리 로그 파일 키로 암호화해서 다시 저장
  - 모든 바이너리 로그와 릴레이 로그 파일이 새로운 바이너리 로그 암호화 키로 다시 암호화됐다면 기존 바이너리 로그 암호화 키를 키링 파일에서 제거

### 5.3. mysqlbinlog 도구 활용

- 트랜잭션 내용을 추적, 백업 복구를 위해 암호화된 바이너리 로그를 평문으로 복호화 필요성이 있을 수 있음
- 암호화된 바이너리 로그 파일은 암호화 키가 필요, 해당 키는 MySQL 서버만 가지고 있어서 복호화가 불가능
- mysqlbinlog 도구를 이용해도 로그 파일을 직접 열어 볼수 없다는 에러 메시지 출력
- 바이너리 로그 암호화 키는 그 바이너리 로그, 릴레이 로그를 생성한 MySQL 서버만 가지고 있기 때문에 서버를 통해 가져오는 방법이 유일
