## Chapter 7. 데이터 암호화

> 암호화 기능은 MySQL 5.7부터 지원되기 시작 (only 데이터 파일(테이블스페이스)) <br>
MySQL 8.0부터 리두 로그, 언두 로그, 복제를 위한 바이너리 로그 등도 암호화 기능 지원
>
- 응용 프로그램의 암호화는 주로 중요 정보를 가진 컬럼 단위로 암호화를 수행
- 데이터베이스 수준에서는 테이블 단위로 암호화를 적용

<br>

### MySQL 서버

- 데이터의 암호화/복호화는 DB 서버와 디스크 사이의 데이터를 읽고 쓰기 지점(InnoDB I/O 레이어)에서 수행함
  - 따라서 디스크 입출력 이외의 부분에서는 암호화 처리가 전혀 필요하지 않음
  - 레이어 계층을 잘 나눈 것 같다는 생각이 듬

<br>

#### TDE (Transparent Data Encryption)

- 메모리나 네트워크 전송 단계가 아닌 디스크에 저장되는 단계에서만 암호화된다는 의미
- 사용자의 쿼리 처리 시, 테이블의 데이터가 암호화돼 있는지 여부를 식별할 필요가 없음
  - 암호화 기능이 활성화 되어 있더라도 MySQL 내부와 사용자 입장에서는 차이가 없음
  - 단지 DB I/O 시에만 I/O 레이어가 암,복호화 담당

<br>

### 2단계 키 관리

> MySQL은 마스터 키와 테이블스페이스 키(private key) 두가지 종류의 키를 가진다
>
1. 외부 키 관리 솔루션 or 디스크의 파일(keyring_file 플러그인)  등을 사용하여 `마스터 키`를 가져온다
2. 암호화된 테이블이 생성될 때마다 해당 테이블을 위한 임의의 `테이블스페이스 키를 발급`
3. MySQL 서버는 `마스터 키를 이용해 테이블 스페이스 키를 암호화`해서 각 `테이블의 데이터 파일 헤더에 저장`
4. 이렇게 생성된 테이블스페이스 키는 테이블이 삭제되지 않는 이상 절대 변경 안됨
  - 또한 테이블스페이스 키는 절대 MySQL 서버 외부로 노출되지 않음 (보안 굿)
  - 하지만 마스터 키는 외부 파일을 이용하므로 노출 가능성 있음 (보안 배드)
- 따라서 마스터 키는 주기적으로 변경해주어야 한다
  - `ALTER INSTANCE ROTATE INNODB MASTER KEY;`

<br>

#### 마스터 키 변경

> 키를 2단계로 관리하는 주요 목적은 암호화 키 변경으로 인한 과도한 시스템 부하를 피하기 위해서다
>
1. 기존의 마스터 키를 이용해 각 테이블의 테이블스페이스 키를 복호화
2. 새로운 마스터 키 발급
3. 새로운 마스터 키로 모든 테이블스페이스 키 암호화
- 이렇게 함으로써 테이블스페이스 키 자체는 변경되지 않으므로 데이터 파일의 데이터는 전혀 변경되지 않는다
- 만약 테이블스페이스 키 자체가 변경된다면 MySQL 서버는 해당 테이블의 데이터파일에 있는 모든 데이터를 다시 복호화했다가 다시 암호화해야된다.
  - 엄청난 작업과 과도한 부하 → 사용자 쿼리 처리에 상당한 영향

<br>

### 암호화와 성능

- MySQL 서버는 디스크로부터 한번 읽은 데이터 페이지는 복호화되어 InnoDB 버퍼 풀에 적재
  - 버퍼 풀에 없는 디스크에서의 최초 조회는 복호화 과정에 의해 쿼리 처리 지연 발생
- 암호화 된 테이블의 변경 점 또한 디스크로 저장될 때 암호화 과정에 의해 추가 시간 발생
  - 하지만 데이터 페이지 저장은 사용자의 쿼리를 처리하는 스레드와 별도의 스레드임
  - 따라서 실제 사용자 쿼리가 지연되는 것은 아님
  - 디스크에서 버퍼 풀로 최초 조회할 때만 쿼리 지연 발생
- 암호화를 해도 기존 데이터 파일의 크기와 동일하기에, 데이터 크기에 의한 버퍼 풀 비효율, 메모리 사용 비효율 현상은 일어나지 않음
  - 단지 암호화/복호화에 의한 쿼리 지연 현상만 발생
- 압축과 암호화를 동시에 사용할 때는 **압축을 먼저 실행한 후 암호화를 적용**하자

<br>

### 암호화와 복제

- 마스터 키는 각 노드마다 각자의 마스터 키를 할당받아야 됨
- 따라서 소스 서버와 레플리카 서버는 각자의 마스터 키와 테이블 스페이스 키를 관리
  - 이에 복제된 데이터 파일은 암호화 되기 전의 값이 동일하더라도 실제 암호화된 데이터 파일의 내용은 다름
  - 그래도 원본 데이터(복호화된 평문 데이터)는 동일하니 딱히 문제는 없을 듯

<br>

### 테이블 암호화

- 일반 CREATE TABLE 문 마지막에 `“ENCRYPTION= ‘Y’”`옵션만 추가해주면 됨
- 이렇게 생성된 테이블에는 데이터가 디스크에 기록될 때 자동으로 데이터가 암호화되어 저장되고 조회될 때 복호화되면서 나온다
- 모든 테이블에 대해 암호화를 적용하고 싶다면 시스템 변수 `default_table_encryption`을 ON으로 설정하자

<br>

### 응용 프로그램 암호화 vs 데이터베이스 암호화

- 응용 프로그램에서 암호화 된 컬럼은 인덱스를 생성하더라도 인덱스의 기능을 100% 활용 못함
  - 암호화 된 값을 기준으로 정렬됨
- MySQL 암호화 기능(TDE)를 사용하면 모든 인덱스 관련 작업을 처리 후 실제 디스크에 I/O 될때만 암/복호화를 진행하기에 별다른 제약이 없음
  - 따라서 저자는 둘 중에는 고민할 필요 없이 MySQl 서버의 암호화 기능을 선택할 것을 권장한다고 함
  - 하지만 MySQL 서버의 로그인만 뚫는다면 모든 데이터를 평문으로 확인할 수 있는 단점
- 하지만 각자의 목적과 용도가 다르기에 Trade-off를 고려하면 됨
  - 정말 중요한 데이터라면 이중 암호화를 할 듯

<br>

### 테이블 스페이스 이동

- 테이블을 다른 서버로 복사해야 되는 경우 or 특정 테이블의 데이터 파일만 백업했다가 복구하는 경우
  - `Dump & Restore` 대신 `Export & Import`(테이블스페이스 이동)를 사용하자
  - 훨씬 효율적이고 빠르다
- Export 명령어를 실행하면 해당 테이블에 저장되지 않은 변경 사항을 모두 디스크로 기록하고, 더 이상 테이블에 접근할 수 없게 락을 건다
  - `FLUSH TABLES source_table FOR EXPORT;`
  - 암호화된 테이블의 경우 부가적으로 신경써줘야 함 (206쪽 참고)

<br>

### 언두 로그, 리두 로그, 바이너리 로그 암호화

- 리두 로그와 언두 로그 특징
  - 암호화를 비활성화하거나 활성화 하면 그 시점부터 들어오는 데이터에 대해 적용이 됨
  - 따라서 암호화를 비활성화 했다고 바로 암호화 키가 필요없어지는게 아님
  - 상황에 따라선 비활성화 한지 몇 달 동안도 암호화된 데이터가 남아있을 수 있음
- 리두 로그와 언두 로그를 위한 각각의 프라이빗 키가 발급되고, 각각의 파일 헤더에 저장됨
  - 실제 테이블의 암호화에 사용되는 테이블스페이스 키와 별개
- 바이너리 로그는 디스크에 저장된 로그 파일에 대한 암호화만 담당
  - 복제 멤버 간의 네트워크 구간에서도 바이너리 로그를 암호화하려면 SSL 사용 필요
- 바이너리 로그 암호화 키 관리 또한 2단계 암호화 키 관리 방식을 사용
